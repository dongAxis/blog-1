<!--
{
  "title": "Using Sway Window Manager",
  "date": "2017-05-14T18:07:20+09:00",
  "category": "",
  "tags": ["linux", "wayland"],
  "draft": true
}
-->

# Following source

```
[ Data structure ]
(sway)
struct sway_config *config
struct key_state key_state_array[]
swayc_t root_container
swayc_t *current_focus
log_importance_t v

(wlc, wl)
wlc
'-' wlc_compositor
'-' wlc_interface (a set of callbacks)
'-' wl_display
  '-' wl_event_loop
  '-' global_list
  '-' client_list

wlc_compositor
'-' wlc_backend
'-' wlc_seat
'-' wlc_shell
'-' wl_global compositor
'-* outputs, views, surfaces, subsurfaces, regions

logind
'-' seat
'-' DBusConnection

input
'-' libinput

udev
'-' udev (handle)
'-' udev_monitor
'-' wl_event_source


wlc_output
'-' wlc_output_information
  '-' (mostly copied from drm_surface's kms)
'-' wlc_backend_surface
  '-' drm_surface (as internal)
    '-' drmModeConnector, drmModeEncoder, drmModeCrtc
    '-' drm_fb
      '-' gbm_bo
  '-' drm_fd


[ Main path ((*) indicates wayland event loop callback registration) ]
- main =>
  - register_wlc_handlers =>
    - wlc_set_output_created_cb(handle_output_created) =>
      - wlc.interface.output.created = handle_output_created
    - wlc_set_view_created_cb, wlc_set_input_created_cb, etc ..
  - wlc_init =>
    - wlc.display = wl_display_create =>
      - wl_event_loop_create => epoll_create1
    - vt = wlc_logind_init =>
      - sd_pid_get_session, sd_session_get_seat, sd_session_get_vt
      - wlc_dbus_open => dbus_bus_get_private, dbus_bind
      - setup_dbus => ...
      - take_control => dbus_message_new_method_call(... "TakeControl")
    - wlc_tty_init =>
      - open_tty => open
      - setup_tty =>
        - ioctl(fd, KDSETMODE, KD_GRAPHICS) and etc...
    - wlc_fd_init =>
      - (why do we open files in this child ? for safety or something ?)
      - socketpair and fork
      - on child, communicate with parent for opening file while (kill(parent, 0) == 0)
    - (*) wl_signal_add(&wlc.signals.compositor, &compositor_listener)
    - wlc_resources_init => ...
    - wl_display_add_socket_auto =>
      - struct wl_socket *s = wl_socket_alloc
      - wl_socket_init_for_display_name
      - _wl_display_add_socket => bind, listen, and wl_event_loop_add_fd
    - wl_display_init_shm =>
      - wl_global_create(.. wl_shm_interface .. bind_shm) =>
        - struct wl_global *global = malloc
        - wl_list_insert(display->global_list, ...)
        - wl_resource_post_event
    - wlc_udev_init =>
      - udev_new, udev_monitor_new_from_netlink
      - udev_monitor_filter_add_match_subsystem_devtype "drm" and "input"
      - udev_set_event_loop =>
        - (*) wl_event_loop_add_fd(..., udev_monitor_get_fd(udev.monitor), ..., udev_event, ...) =>
          - add_source => epoll_ctl(... EPOLL_CTL_ADD)
      - (*) wl_signal_add(&wlc_system_signals()->activate, &activate_listener)
    - wlc_input_init =>
      - libinput_udev_create_context
      - libinput_udev_assign_seat
      - input_set_event_loop =>
        - (*) wl_event_loop_add_fd(..., libinput_get_fd(input.handle), input_event, ...)
    - wlc_compositor =>
      - (*) wl_signal_add (e.g. compositor->listener.activate, terminate, xwayland, surface, output, focus)
      - wl_global_create(.. wl_compositor_interface, .. wl_compositor_bind)
      - wlc_seat =>
        - wl_global_create(.. wl_seat_interface ..)
      - wlc_backend =>
        - wlc_drm =>
          - wlc_fd_open => wlc_logind_open => take_device (is this equivalent to setDrmMaster ??) =>
            - dbus_message_new_method_call "TakeDevice"
            - fcntl F_GETFL
          - gbm_create_device (from mesa) => ??
          - (*) wl_event_loop_add_fd(..., drm.fd, ..., drm_event)
          - backend->api.update_outputs = update_outputs
  - register_extensions =>
    - wl_global_create(.. desktop_shell_interface .. desktop_shell_bin)
    - wl_global_create(.. lock_interface .. swaylock_bind)
  - init_layout =>
    - root_container.id = 0
    - current_focus = &root_container
  - ipc_init =>
    - socket, bind on SWAYSOCK, and listen
    - (*) wlc_event_loop_add_fd(ipc_socket, ..., ipc_handle_connection, ..) => wl_event_loop_add_fd
  - load_main_config =>
    - input_init
    - load_config
    - update_active_bar_modifiers
  - wlc_run =>
    - wlc_set_actives => wl_signal_emit(&wlc.signals.activate, ...) => (SEE BELOW, for possible callbacks)
    - wl_display_run =>
      - while (display->run)
        - wl_display_flush_clients => ...
        - wl_event_loop_dispatch =>
          - epoll_wait
          - struct wl_event_source *source = ep[i].data.ptr
          - source->interface->dispatch => ...(one of callbacks)


[ on activate ]
- activate_event (compositor.c) =>
  - activate_tty => wlc_fd_activate => wlc_tty_activate => ioctl(wlc.tty, VT_RELDISP...)
  - wlc_backend_update_outputs => update_outputs (drm.c) =>
    - query_drm (kms-based device discovery) =>
      - drmModeGetResources, drmModeGetConnector
      - find_encoder_for_connector =>
      - find_crtc_for_encoder =>
      - wlc_output_information
      - wlc_output_information_add_mode
    - gbm_surface_create(... GBM_BO_FORMAT_XRGB8888, GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING) => ???
    - add_output(... ) =>
      - wlc_backend_surface
      - wl_signal_emit(&wlc_system_signals()->output, &ev) (WLC_OUTPUT_EVENT_ADD) => (TO COMPOSITOR, SEE BELOW)

- activate_event (session/udev.c) =>
  - libinput_resume => ?


[ output event ]
- output_event (compositor.c)
  - (for WLC_OUTPUT_EVENT_ADD) add_output =>
    - ??


[ udev output event ]

[ libinput event ]

[ drm event ]

[ wayland client event ]


[ Logging facility ]
(sway)
typedef enum {
	L_SILENT = 0,
	L_ERROR = 1,
	L_INFO = 2,
	L_DEBUG = 3,
} log_importance_t;
- main =>
  - wlc_log_set_handler(wlc_log_handler) => wlc.log_fun = ...
- sway_log => _sway_log => _sway_vlog => chekc if (verbosity <= v) ...

(wlc)
enum wlc_log_type {
   WLC_LOG_INFO,
   WLC_LOG_WARN,
   WLC_LOG_ERROR,
   WLC_LOG_WAYLAND,
};
- wlc_init =>
  - wl_log_set_handler_server(wl_cb_log) => wl_log_handler = ...
- wlc_log(type, ) => wlc_vlog(type, ) => wlc.log_fun (i.e. wlc_log_handler from sway) => sway_log
- wlc_dlog => wlc_vlog(WLC_LOG_INFO, ) => ...

(wl)
- wl_log => wl_log_handler (i.e. wl_cb_log) =>
  - wlc_vlog(WLC_LOG_WAYLAND, ...)
```


Process tree

```
└─sway─┬─Xwayland─┬─{llvmpipe-0}
       │          ├─{llvmpipe-1}
       │          ├─{llvmpipe-2}
       │          └─{llvmpipe-3}
       ├─sway
       ├─swaybar──...
       └─swaybg
```

capability setup:

```
sudo setcap "cap_sys_ptrace+eip cap_sys_tty_config+eip" out/example/example
```


# TODO

- learn xkb (capslock as control)
  - wlc and libinput
  - xkb 101: http://pascal.tsu.ru/en/xkb/
  - https://github.com/SirCmpwn/sway/wiki#keyboard-layout
  - setxkbmap(1)
    - /usr/share/rules/base (ctrl:nocaps =	+ctrl(nocaps))
    - /usr/share/symbols/ctrl (xkb_symbols "nocaps" { ... })
- acpi special key
  - acpid: http://sourceforge.net/projects/acpid2/
  - volume: https://wiki.archlinux.org/index.php/Acpid#Enabling_volume_control
- log from sway/wlc/wayland
  - sway: --debug
  - wlc: WLC_DEBUG=handle,render,render-loop,focus,xwm,keyboard,commit,request
  - wayland: WAYLAND_DEBUG=server (or 1)
