<!--
{
  "title": "V8: Compiling Javascript",
  "date": "2017-03-25T01:54:33+09:00",
  "category": "",
  "tags": ["javascript", "source"],
  "draft": true
}
-->

# Following samples/shell.cc

```
[ Basic Steps ]
- platform::CreateDefaultPlatform => this spawns 3 WorkerThread s
- InitializePlatform(platform)
- Isolate::New
- (block)
  - Isolate::Scope isolate_scope
  - HandleScope handle_scope
  - (Local) v8::Context::New
  - Context::Scope context_scope
  - (loop for)
    - HandleScope handle_scope
    - (Local) Isolate::GetCurrentContext
    - (Local) Script
    - Script::Compile
    - Script::Run
    - platform::PumpMessageLoop

[ Compilation (Ignition bytecode) ]
- Script::Compile => ScriptCompiler::Compile =>
  - CompileUnboundInternal =>
    - Compiler::GetSharedFunctionInfoForScript (with NON_NATIVES_CODE)
      - Factory::NewScript
      - set Script::Typescript (e.g. TYPE_NATIVE)
      - prepare ParseInfo, Zone, CompilationInfo
      - CompileToplevel =>
        - parsing::ParseProgram =>
          - Parser::ParseProgram =>
            - DoParseProgram (handmade lexer/parser implementation. let's not follow for now)
            - (PrintF when FLAG_trace_parse)
          - ParseInfo::setLiteral
        - NewSharedFunctionInfoForLiteral =>
          - Builtins::CompileLazy (defined by BUILTIN_LIST_ALL(DEFINE_BUILTIN_ACCESSOR))
            - returns address of some executable text (builtins_[kCompileLazy] ?)
          - Factory::NewSharedFunctionInfo =>
            - SharedFunctionInfo::set_code
          - SharedFunctionInfo::InitFromFunctionLiteral
        - CompileUnoptimizedCode =>
          - Compiler::Analyze =>
            - Rewriter::Rewrite (see comment class Rewriter) => Processor::Process (as ASTVisitor)
            - DeclarationScope::Analyze (see comment class Scope) =>
              - AllocateVarialbe =>
                - Scope::ResolveVariablesRecursively (see comment class Variable)
                - AllocateVariablesRecursively
                - AllocateScopeInfosRecursively
            - Renumber
          - CompileUnoptimizedInnerFunctions =>
            - GenerateUnoptimizedCode =>
              - GetUnoptimizedCompilationJob => ... => new InterpreterCompilationJob
              - InterpreterCompilationJob::ExecuteJob => ExecuteJobImpl =>
                - BytecodeGenerator::GenerateBytecode =>
                  - (do its stuff using BytecodeArrayBuilder as AstVisitor, follow this later)
              - FinalizeUnoptimizedCompilationJob =>
                - InterpreterCompilationJob::FinalizeJob => FinalizeJobImpl =>
                  - BytecodeGenerator::FinalizeBytecode (emit BytecodeArray)
                  - (if FLAG_print_bytecode, BytecodeArray::Print, which leads to BytecodeArray::Disassemble)
                  - CompilationInfo::SetBytecodeArray
                  - CompilationInfo::SetCode (builtin's InterpreterEntryTrampoline)
                - InstallUnoptimizedCode
                  - InstallSharedCompilationResult
                    - SharedFunctionInfo::ReplaceCode with CompilationInfo.code
                    - SharedFunctionInfo::set_bytecode_array to CompilationInfo.bytecode_array
    - return UnboundScript with SharedFunctionInfo
  - UnboundScript::BindToCurrentContext =>
    - cast to SharedFunctionInfo
    - Factory::NewFunctionFromSharedFunctionInfo =>
      - NewFunction
      - (returns JSFunction)

[ Execution ]
- Script::Run => Execution::Call => CallInternal => Invoke =>
  - code = Factory::js_entry_code (relavant macros ROOT_ACCESSOR, ROOT_LIST, STRONG_ROOT_LIST)
  - JSEntryFunction stub_entry = Code::entry
  - CALL_GENERATED_CODE (which actually calls stub_entry as normal C function)
    - cannot track debug symbol ??

[ Data Structure ]
[[ v8 api ]]
Platform
Isolate
Context
Context::Scope
HandleScope
Value
Local<T>
MaybeLocal
ScriptCompiler, Compiler
Source
UnboundScript
Script (how does i::Handle<i::JSFunction>::cast(Utils::OpenHandle(script)) work ?)

[[ internal ]]
VMState
Context

CompilationInfo
'-' ParseInfo
  '-' Script (extends Struct)
    '-' Object (as source string)
    '-' Object (as name of script)
  '-' FunctionLiteral (AST expression)

SharedFunctionInfo (extends HeapObject)
'-' Code
'-' AbstractCode

FunctionLiteral (extends Expression)
'-' AstString (as raw_name_)
'-* Statement (as body_)
'-' DeclarationScope

DeclarationScope (extends Scope)

- Variable
- VariableProxy

[ Runtime options ]
See src/flag-definitions.h:
- print ignition bytecode (--print_bytecode)
- print javascript ast (--print_ast)
- print turbofan/crankshaft native code generation (?)
```

# Code generation details

- Bytecode generation

```
## Example is `1 + 1 === 1 + 1 ? 2 : 3` ##

[ AST printed within debugger ]
(lldb) expr stmt->Print()
EXPRESSION STATEMENT at 0
. ASSIGN at -1
. . VAR PROXY local[0] (mode = TEMPORARY) ".result"
. . CONDITIONAL at 0
. . . CONDITION at 6
. . . . EQ_STRICT at 6
. . . . . LITERAL 2
. . . . . LITERAL 2
. . . THEN at 18
. . . . LITERAL 2
. . . ELSE at 22
. . . . LITERAL 3

[ Trace from --print_bytecode ]
Parameter count 1
Frame size 16
    0 E> 0x8a5e05abda6 @    0 : 88                StackCheck
    0 S> 0x8a5e05abda7 @    1 : 03 02             LdaSmi [2]
         0x8a5e05abda9 @    3 : 1f f9             Star r1
         0x8a5e05abdab @    5 : 03 02             LdaSmi [2]
    6 E> 0x8a5e05abdad @    7 : 56 f9 02          TestEqualStrict r1, [2]
         0x8a5e05abdb0 @   10 : 7f 06             JumpIfFalse [6] (0x8a5e05abdb6 @ 16)
         0x8a5e05abdb2 @   12 : 03 02             LdaSmi [2]
         0x8a5e05abdb4 @   14 : 72 04             Jump [4] (0x8a5e05abdb8 @ 18)
         0x8a5e05abdb6 @   16 : 03 03             LdaSmi [3]
         0x8a5e05abdb8 @   18 : 1f fa             Star r0
   23 S> 0x8a5e05abdba @   20 : 8c                Return

[ BytecodeGenerator path ]
- BytecodeGenerator::GenerateBytecode =>
  - GenerateBytecodeBody =>
    - VisitStatements =>
      - Visit (macro from DEFINE_AST_VISITOR_SUBCLASS_MEMBERS) => ... =>
        - VisitConditional =>
          - (check if we can skip conditional by ToBooleanIsTrue and ToBooleanIsFalse, but curren case, it didn't reduce that.)
          - VisitForTest =>
            - Visit => VisitCompareOperation =>
              - VisitForRegisterValue (for lhs `2` (actually `1 + 1` is folded somewhere)) =>
                - VisitForAccumulatorValue =>
                  - ValueResultScope::ValueResultScope (pair with ~ValueResultScope)
                  - Visit => VisitLiteral =>
                    - BytecodeArrayBuilder::LoadLiteral =>
                      - AstValue::AsSmi
                      - LoadLiteral => OutputLdaSmi (defined from BYTECODE_LIST(DEFINE_BYTECODE_OUTPUT)) =>
                        - BytecodeNodeBuilder<kOutputLdaSmi>::Make =>
                          - (some optimization called BytecodeRegisterOptimizer::PrepareOutputRegister, for now ignore it)
                          - BytecodeNote::Create =>
                        - (optimization opportunities along Write bytecode)
                          - BytecodePeepholeOptimizer::Write => ... => DefautAction =>
                          - BytecodeDeadCodeOptimizer::Write (PeepholeOptimizer keeps and passes last node which is `StackCheck`) =>
                          - BytecodeArrayWriter::Write => EmitBytecode =>
                            - vector::push_back(Bytecodes::ToByte(bytecode))
                  - ValueResultScope::~ValueResultScope =>
                    - BytecodeGenerator::set_execution_result
                - BytecodeRegisterAllocator::NewRegister => Register
                - BytecodeRegisterOptimizer::DoStar => RegisterTransfer (kinda going too far. ignore it for now...)
                - (return Register)
              - VisitForAccumulatorValue (for rhs) => (... similar pattern as above, except crazy optimization stages)
              - CompareOperationFeedbackSlot
              - BytecodeArrayBuilder::CompareOperation => OutputTestEqualStrict => ...
            - BytecodeArrayBuilder::JumpIfFalse (to "else" label) => OutputJumpIfToBooleanFalse
          - (bind "then" label to builder (I guess this is for jump offset calculation happens later ?))
          - VisitForAccumulatorValue ("then" expr) => ...
          - BytecodeArrayBuilder::Jump (to "end" label)
          - (bind "else" label to builder)
          - VisitForAccumulatorValue ("else" expr) => ...
          - (bind "end" label to builder)

```

- Bytecode handler generation
  - Q?. Understand the way turbofan emit this code
      - Bytecode operation -> Turbofan IR -> x86 ?
      - what's safepoints and relocinfo (when relocation (linking) happens ?)
      - I should trace turbofan right ?

```
[Initilization (compile builtins and bytecode handlers)]
- Isolate::Init =>
  - Builtins::Setup =>
    - (for each builtin code (e.g. InterpreterEntryTrampoline))
      - BuildWithMacroAssembler =>
        - Builtins::Generate_InterpreterEntryTrampoline (as MacroAssemblerGenerator, see below for detail)
        - MacroAssembler::GetCode
      - assign compiled Code to builtins_[kInterpreterEntryTrampoline]
  - Interpreter::Initialize =>
    - (for each bytecode from BYTECODE_LIST (e.g. Bytecode::kDoLdaZero))
      - Interpreter::InstallBytecodeHandler(...kDoLdaZero)
        - GenerateBytecodeHandler
          - InterpreterDispatchDescriptor
          - InterpreterAssembler
          - InterpreterGenerator.DoLdaZero => (see below)
          - CodeAssembler::GenerateCode
          - (if FLAG_trace_ignition_codege, print Code::Disassemble)
        - assign compiled Code entry to dispatch_table_[index]

[Assembly code generation for bytecode handler (via turbofan)]
- InterpreterGenerater::DoLdaZero =>
  - CodeAssembler::NumbrtConstant => RawAssemmbler::NumberConstant =>
    - CommonOperatorBuilder::NumberConstant
    - AddNode
  - InterpreterAssembly::SetAccumulator =>
    - CodeAssemblerVariable::Bind(Node) (accumulator is just a variable?)
  - InterpreterAssembly::Dispatch => DispatchToBytecodeHandlerEntry =>
    - CodeAssembler::TailCallBytecodeDispatch =>
      - RawMachimeAssembler::TailCallN =>
        - CommonOperatorBuilder::TailCall
        - MakeNode
        - Schedule::addTailCall (add TurboFan graph edges between Node or block?)

- InterpreterGenerater::DoLdar => ?
  - InterpreterAssembler::BytecodeOperandReg =>
  - InterpreterAssembler::LoadRegister
  - InterpreterAssembler::SetAccumulator
  - InterpreterAssembler::Dispatch

$ out.gn/x64.debug/v8_shell --trace_ignition_codegen # show only Ldar part
kind = BYTECODE_HANDLER
name = Ldar
compiler = turbofan
Instructions (size = 68)
0x1e6c16e0480     0  4b0fbe442601   REX.W movsxbq rax,[r14+r12*1+0x1]
0x1e6c16e0486     6  488bdd         REX.W movq rbx,rbp
0x1e6c16e0489     9  488b04c3       REX.W movq rax,[rbx+rax*8]
0x1e6c16e048d     d  4983c402       REX.W addq r12,0x2
0x1e6c16e0491    11  430fb61c34     movzxbl rbx,[r12+r14*1]
0x1e6c16e0496    16  49ba0000000001000000 REX.W movq r10,0x100000000
0x1e6c16e04a0    20  4c3bd3         REX.W cmpq r10,rbx
0x1e6c16e04a3    23  7310           jnc 0x1e6c16e04b5  <+0x35>
0x1e6c16e04a5    25  48ba0000000001000000 REX.W movq rdx,0x100000000
0x1e6c16e04af    2f  e8ac3ce2ff     call 0x1e6c1504160  (Abort)    ;; code: BUILTIN
0x1e6c16e04b4    34  cc             int3l
0x1e6c16e04b5    35  498b1cdf       REX.W movq rbx,[r15+rbx*8]
0x1e6c16e04b9    39  ffe3           jmp rbx
0x1e6c16e04bb    3b  90             nop

Safepoints (size = 8)

RelocInfo (size = 1)
0x1e6c16e04b0  code target (BUILTIN)  (0x1e6c1504160)


-- Schedule --------------------------------------
--- BLOCK B0 ---
  1: Parameter[0](0)
  2: Parameter[1](0)
  3: Parameter[2](0)
  4: Parameter[3](0)
  5: Parameter[4](0)
  7: Int64Constant[1]
  8: Int64Add(2, 7)
  9: Load[kRepWord32|kTypeInt32](3, 8)
  10: ChangeInt32ToInt64(9)
  11: LoadParentFramePointer
  12: Int64Constant[3]
  13: Word64Shl(10, 12)
  14: Load[kRepTagged|kTypeAny](11, 13)
  15: Int64Constant[5]
  16: Int64Add(2, 15)
  17: Load[kRepWord8|kTypeUint32](3, 16)
  18: ChangeUint32ToUint64(17)
  19: Int64Constant[3]
  20: Word64Shl(18, 19)
  21: Load[kRepWord64](4, 20)
  22: TailCall[Addr:InterpreterDispatch Descriptor:r0s0i5f0t1](21, 14, 16, 3, 4) -> B1
--- BLOCK B1 <- B0 ---
----- Instruction sequence before register allocation -----
IMM#0: 5l
IMM#1: 1l
B0: AO#0 (no frame)  instructions: [0, 11)
 predecessors:
       0: gap () ()
          [r12|R|w64] = ArchNop
       1: gap (v7(-) = [r12|R|w64];) ()
          [r14|R|t] = ArchNop
       2: gap (v3(-) = [r14|R|t];) ()
          [r15|R|w64] = ArchNop
       3: gap (v4(-) = [r15|R|w64];) ()
          v9(R) = X64Movsxlq : MR1I v3(R) v7(R) [immediate:1]
       4: gap () ()
          v8(R) = ArchParentFramePointer
       5: gap () ()
          v1(R) = X64Movq : MR8 v8(R) v9(R)
       6: gap () ()
          v2(R) = X64Lea : MRI v7(R) [immediate:0]
       7: gap () ()
          v6(R) = X64Movzxbl : MR1 v2(R) v3(R)
       8: gap () ()
          v0(R) = X64Movq : MR8 v4(R) v6(R)
       9: gap () ()
          ArchPrepareTailCall
      10: gap () ([rax|R|t] = v1(-); [r12|R|w64] = v2(-); [r14|R|t] = v3(-); [r15|R|w64] = v4(-);)
          ArchTailCallAddress v0(R) [rax|R|t] [r12|R|w64] [r14|R|t] [r15|R|w64] #1
 B1
B1: AO#1 (no frame)  instructions: [11, 12)
 predecessors: B0
      11: gap () ()
          ArchNop

----- Instruction sequence after register allocation -----
IMM#0: 5l
IMM#1: 1l
B0: AO#0 (no frame)  instructions: [0, 11)
 predecessors:
       0: gap () ()
          [r12|R|w64] = ArchNop
       1: gap () ()
          [r14|R|t] = ArchNop
       2: gap () ()
          [r15|R|w64] = ArchNop
       3: gap () ()
          [rax|R|w64] = X64Movsxlq : MR1I [r14|R|t] [r12|R|w64] [immediate:1]
       4: gap () ()
          [rbx|R|w64] = ArchParentFramePointer
       5: gap () ()
          [rax|R|t] = X64Movq : MR8 [rbx|R|w64] [rax|R|w64]
       6: gap () ()
          [r12|R|w64] = X64Lea : MRI [r12|R|w64] [immediate:0]
       7: gap () ()
          [rbx|R|w64] = X64Movzxbl : MR1 [r12|R|w64] [r14|R|t]
       8: gap () ()
          [rbx|R|w64] = X64Movq : MR8 [r15|R|w64] [rbx|R|w64]
       9: gap () ()
          ArchPrepareTailCall
      10: gap () ()
          ArchTailCallAddress [rbx|R|w64] [rax|R|t] [r12|R|w64] [r14|R|t] [r15|R|w64] #1
 B1
B1: AO#1 (no frame)  instructions: [11, 12)
 predecessors: B0
      11: gap () ()
          ArchNop

kind = BYTECODE_HANDLER
name = Ldar
compiler = turbofan
Instructions (size = 68)
0x2029f233c080     0  4b63442601     REX.W movsxlq rax,[r14+r12*1+0x1]
0x2029f233c085     5  488bdd         REX.W movq rbx,rbp
0x2029f233c088     8  488b04c3       REX.W movq rax,[rbx+rax*8]
0x2029f233c08c     c  4983c405       REX.W addq r12,0x5
0x2029f233c090    10  430fb61c34     movzxbl rbx,[r12+r14*1]
0x2029f233c095    15  49ba0000000001000000 REX.W movq r10,0x100000000
0x2029f233c09f    1f  4c3bd3         REX.W cmpq r10,rbx
0x2029f233c0a2    22  7310           jnc 0x2029f233c0b4  <+0x34>
0x2029f233c0a4    24  48ba0000000001000000 REX.W movq rdx,0x100000000
0x2029f233c0ae    2e  e8ad80dcff     call 0x2029f2104160  (Abort)    ;; code: BUILTIN
0x2029f233c0b3    33  cc             int3l
0x2029f233c0b4    34  498b1cdf       REX.W movq rbx,[r15+rbx*8]
0x2029f233c0b8    38  ffe3           jmp rbx
0x2029f233c0ba    3a  6690           nop


Safepoints (size = 8)

RelocInfo (size = 1)
0x2029f233c0af  code target (BUILTIN)  (0x2029f2104160)
```

- Interpreter entry trampoline

```
- Builtins::Generate_InterpreterEntryTrampoline (x64/builtins-x64.cc) => ??
```

# Some Examples

```
[ AST example ]
$ out.gn/x64.debug/v8_shell --print_ast
> (function fib(n) { return (n <= 1 ? n : fib(n - 1) + fib(n - 2)); })(10)
[generating interpreter code for user-defined function: fib]
--- AST ---
FUNC at 1
. KIND 0
. SUSPEND COUNT 0
. NAME "fib"
. INFERRED NAME ""
. PARAMS
. . VAR (mode = VAR) "n"
. EXPRESSION STATEMENT at -1
. . INIT at -1
. . . VAR PROXY local[0] (mode = CONST) "fib"
. . . THIS-FUNCTION at 1
. RETURN at 19
. . CONDITIONAL at 27
. . . CONDITION at 29
. . . . LTE at 29
. . . . . VAR PROXY parameter[0] (mode = VAR) "n"
. . . . . LITERAL 1
. . . THEN at 36
. . . . VAR PROXY parameter[0] (mode = VAR) "n"
. . . ELSE at 51
. . . . ADD at 51
. . . . . CALL Slot(1)
. . . . . . VAR PROXY local[0] (mode = CONST) "fib"
. . . . . . SUB at 46
. . . . . . . VAR PROXY parameter[0] (mode = VAR) "n"
. . . . . . . LITERAL 1
. . . . . CALL Slot(4)
. . . . . . VAR PROXY local[0] (mode = CONST) "fib"
. . . . . . SUB at 59
. . . . . . . VAR PROXY parameter[0] (mode = VAR) "n"
. . . . . . . LITERAL 2


[ Bytecode generation example ]
$ out.gn/x64.debug/v8_shell --print_bytecode
> (function fib(n) { return (n <= 1 ? n : fib(n - 1) + fib(n - 2)); })(10)
[generating bytecode for function: fib]
Parameter count 2
Frame size 40
   13 E> 0x171d3046f5e6 @    0 : 88                StackCheck
         0x171d3046f5e7 @    1 : 20 fe fa          Mov <closure>, r0
   19 S> 0x171d3046f5ea @    4 : 03 01             LdaSmi [1]
   29 E> 0x171d3046f5ec @    6 : 59 02 02          TestLessThanOrEqual a0, [2]
         0x171d3046f5ef @    9 : 7f 06             JumpIfFalse [6] (0x171d3046f5f5 @ 15)
         0x171d3046f5f1 @   11 : 1e 02             Ldar a0
         0x171d3046f5f3 @   13 : 72 23             Jump [35] (0x171d3046f616 @ 48)
         0x171d3046f5f5 @   15 : 04                LdaUndefined
         0x171d3046f5f6 @   16 : 1f f8             Star r2
   46 E> 0x171d3046f5f8 @   18 : 38 01 02 05       SubSmi [1], a0, [5]
         0x171d3046f5fc @   22 : 1f f7             Star r3
   40 E> 0x171d3046f5fe @   24 : 47 fa f8 f7 03    Call1 r0, r2, r3, [3]
         0x171d3046f603 @   29 : 1f f9             Star r1
         0x171d3046f605 @   31 : 04                LdaUndefined
         0x171d3046f606 @   32 : 1f f7             Star r3
   59 E> 0x171d3046f608 @   34 : 38 02 02 08       SubSmi [2], a0, [8]
         0x171d3046f60c @   38 : 1f f6             Star r4
   53 E> 0x171d3046f60e @   40 : 47 fa f7 f6 06    Call1 r0, r3, r4, [6]
   51 E> 0x171d3046f613 @   45 : 2c f9 09          Add r1, [9]
   66 S> 0x171d3046f616 @   48 : 8c                Return

- Notes (read BytecodeArray::Disassemble and BytecodeDecoder::Decode)
  - "S>" is statement and "E>" is expression (with source script offset on its left)
  - types of operands
    - "r" means register in register file (e.g. temporary value)
    - "a" represents argument
    - "[]" is for Uimm (unsigned immidiate) and some others
```

# TODO

- type of compilatio job and how they are triggered
  - CompilationJob (base class)
  - PipelineCompilationJob (turbofan) (triggered from runtime ?)
  - PipelineWasmCompilationJob (web assembly)
  - HCompilationJob (crankshaft)
  - FullCodeGenCompilationJob (full-codegen ?)
  - InterpreterCOmpilationJob (ignition)
- compile non top-level function
- when does v8 handle "Static Semantics: Early Errors" ?
  - parsing or ignition byte compiler ?
- understand basic C++ techniques
  - dynamic casting
      - FUNCTION_CAST
      - reinterpret_cast
- my concerns
  - JIT
      - compilation unit
      - jit call unit
      - dynamic link and jump to JITed code
      - internal representation of ELF ?
  - MessageLoop
      - v8::platform::PumpMessageLoop ?
  - (internal) Threads
  - GC
  - Bridging C++
      - GC concern
  - String representation (UTF8)
- Some Javascript feature I don't know
  - label jump: http://www.ecma-international.org/ecma-262/7.0/index.html#sec-labelled-statements
  - execution context: http://www.ecma-international.org/ecma-262/7.0/index.html#sec-executable-code-and-execution-contexts
- eval semantics
  - when to parse ?
  - context stack ?


# References

- Spec: http://www.ecma-international.org/ecma-262/7.0/index.html
- [Ignition Design Doc](https://docs.google.com/document/d/11T2CRex9hXxoJwbYqVQ32yIPMh0uouUZLdyrtmMoL44/edit?ts=56f27d9d#heading=h.6jz9dj3bnr8t)
- [Turbofan](https://github.com/v8/v8/wiki/TurboFan)

  - [Turbofan IR](https://docs.google.com/presentation/d/1Z9iIHojKDrXvZ27gRX51UxHD-bKf1QcPzSijntpMJBM/edit#slide=id.p)
  - [An overview of the TurboFan compiler](https://docs.google.com/presentation/d/1H1lLsbclvzyOF3IUR05ZUaZcqDxo7_-8f4yJoxdMooU/edit#slide=id.p)
  - [Turbofan JIT design](https://docs.google.com/presentation/d/1sOEF4MlF7LeO7uq-uThJSulJlTh--wgLeaVibsbb3tc/edit#slide=id.p)
