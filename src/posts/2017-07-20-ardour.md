<!--
{
  "title": "Ardour",
  "date": "2017-07-20T21:01:12+09:00",
  "category": "",
  "tags": [],
  "draft": true
}
-->

# TODO

- jack audio/midi, in/out
  - track, bus setup
- playback, recording
- plugin host (lua, lv2)
- mixer view
- editor view
- ardour file format
- build system
- threading


# Overview

```
[ Data structure ]

ARDOUR_UI
'-' ARDOUR::Session
  '-' AudioEngine
    '-' JACKAudioBackend (< AudioBackend)


EventLoop
'-* RequestBufferSupplier

BufferManager
'- ThreadBuffer..


[ Procedure ]

(Main)
- main =>
  - ARDOUR::init =>
    - PBD::init => ..
    - SessionEvent::init_event_pool => new PerThreadPool
    - XXX::make_property_quarks (e.g. AudioRegion::make_property_quarks)
    - ARDOUR::setup_enum_writer => ..
    - SourceFactory::init =>
      - Thread::create(.. peak_thread_work) x 2 (TODO: who are these ?)
    - PluginManager::instance => new PluginManager
    - ControlProtocolManager::instance => new ControlProtocolManager
      (usually no ControlProtocol unless you have dedicated hardware ??)
    - EventLoop::register_request_buffer_factory("midiUI", MidiControlUI::request_factory) =>
      - EventLoop::request_buffer_suppliers.push_back .. (TODO: when is it used ?)
    - BufferManager::init =>
      - new ThreadBufferFIFO, ThreadBufferList, ThreadBuffers
    - ARDOUR::AudioEngine::create => new AudioEngine =>
      - discover_backends => load ARDOUR::AudioBackendInfo from "libjack_audiobackend.so" (jack_api.cc)
  - new ARDOUR_UI =>
    - .. connect signal and callback ..
    - SessionEvent::create_per_thread_pool ("GUI", 4096) => ??
    - new ArdourKeyboard
    - ActionManager::init => Gtk::UIManager::create
    - WM::Manager::register_window (e.g. midi_port_matrix) => ..
    - new ProcessThread
    - attach_to_engine => AudioEngine::Running.connect(.. ARDOUR_UI::engine_running ..)
  - ARDOUR_UI::run (i.e. Gtkmm2ext::UI::run) =>
    - ARDOUR_UI::starting =>
      - audio_midi_setup.get (WM::Proxy<EngineControl>::get) =>
        - new EngineControl =>
          - set_default_state (or set_state) => backend_changed => AudioEngine::set_backend =>
            - ??
        - WindowProxy::setup => ..
      - ARDOUR_UI::get_session_parameters =>
        - load_session =>
          - new Session =>
            - load_state => read "<session_name>.ardour" file and construct XMLTree
            - ensure_engine
            - emit_thread_start => ?
            - auto_connect_thread_start => ?
            - AudioEngine::set_session
            - EngineStateController::set_session
          - Session::add_controllable (e.g. roll_controllable)
          - set_session =>
            - WM::Manager::set_session and others pars
            - .. connect Session event callback (e.g. TransportStateChange -> map_transport_state)
            - start_clocking => Timers::fps_connect(.. ARDOUR_UI::update_clocks)
            - map_transport_state =>
              - roll_button.set_active(true) if Session is playing ..
    - Gtk::Main::run


(UI event handling)
- ?? follow record or playback (aka roll) button callback


(Audio thread)
- ?? instantiate ??
```


# Ardour file format

```
- some_title/
  - some_title.ardour
  - some_title.history
  - plugins/
  - interchage/
    - some_title/
      - audiofiles/
        - xxx.wav ??
      - midifiles/
        - xxx.mid
```


# Reference

- Ardour
  - http://manual.ardour.org/toc/
  - https://ardour.org/development.html
- Jack
  - [./2017-07-19-jack.html](./2017-07-19-jack.html)
- LV2 plugin
  - http://lv2plug.in/ns/
  - https://github.com/pantherb/setBfree
  - https://github.com/calf-studio-gear/calf
- Soundfont
  - http://www.fluidsynth.org/
