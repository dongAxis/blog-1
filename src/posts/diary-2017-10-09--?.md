<!--
{
  "title": "Diary (2017-10-09 -- ?)",
  "date": "2017-10-09T11:02:08+09:00",
  "special": true
}
-->

# 2017-10-09

- Godot 2d rendering, nested viewport
  - why is there single frame delay rendering 3d viewport within 2d ?
      - by default VIEWPORT_UPDATE_WHEN_VISIBLE, which checks if RasterizerStorageGLES3::render_target_was_used,
        which in tern will be true only after RasterizerCanvasGLES3::\_bind_canvas_texture.

```
[ Data structure ]

Sprite < Node2D < CanvasItem
'-' ViewportTexture < Texture

Viewport < Node


[ Procedure ]

- .. = >CanvasItem::_enter_canvas => update =>
  - MessageQueue::push_call(.. "_update_callback")

- .. => CanvasItem::_update_callback =>
  - notification(NOTIFICATION_DRAW) .. =>
    - eg Sprite::_notification
      - Texture::draw_rect_region(RID p_canvas_item ..) =>
        - VisualServerCanvas::canvas_item_add_texture_rect_region =>
          - Item::commands.push_back(new Item::CommandRect) ..

- .. => VisualServerViewport::draw_viewports =>
  - RasterizerGLES3::set_current_render_target => storage->frame.current_rt = rt (for non system window target)
  - _draw_viewport =>
    - (for 3d) VisualServerScene::render_camera => ..
    - (for 2d) VisualServerCanvas::render_canvas =>
      - recursively _render_canvas_item and accumulate RasterizerCanvas::Item into z_list
      - RasterizerCanvasGLES3::canvas_render_items =>
        - loop by Item *p_item_list
          - CanvasShaderGLES3::set_conditional, custom_shader, bind ..
          - _canvas_item_render_commands =>
            - eg Item::CommandRect (ie TYPE_RECT)
              - _bind_canvas_texture => glBindTexture ..
              - glDrawArrays(GL_TRIANGLE_FAN, 0, 4) ((0, 0) -> (1, 0) -> (1, 1) -> (0, 1))


[ Godot Viewport to GL framebuffer ]

- new Viewport => VisualServerViewport::viewport_create => RasterizerStorageGLES3::render_target_create =>
  - new RenderTarget, new Texture (here we still didn't allocate GL resource yet)

- new SceneTree => .. => Viewport::set_size => RasterizerStorageGLES3::_render_target_allocate =>
  - glGenFramebuffers, glGenTextures (depth, color)
  - .. and much more things happening here ..


[ Godot canvas coordinate ]

- RasterizerCanvasGLES3::reset_canvas =>
  - Transform canvas_transform, translate(-w/2, -h/2, 0), scale(2/w, -2/h, 1)
```


- godot
  - instancing: particle, multimesh
  - nested viewport https://github.com/godotengine/godot/issues/11877
  - some rendering issues
      - https://github.com/godotengine/godot/issues/11710
      - https://github.com/godotengine/godot/issues/11670

- gl coordinates system again: https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClipControl.xhtml

  > The default GL clip volume definition is for a origin of GL_LOWER_LEFT and a depth of GL_NEGATIVE_ONE_TO_ONE.


- gl texture structure (gl spec, section 8.5.3)

  > The first group is the lower left back corner of the texture image. Subsequent
  > groups fill out rows of width width from left to right; height rows are stacked from
  > bottom to top forming a single two-dimensional image slice; and depth slices are
  > stacked from back to front.

  - cf. https://www.w3.org/TR/PNG/


- unreal engine 4 build
  - https://aur.archlinux.org/packages/unreal-engine/
  - https://aur.archlinux.org/packages/unreal-tournament-4/ (how come it doesn't have dependency on engine ??)
  - https://aur.archlinux.org/packages/unrealtournament4/ (binary)


# 2017-10-10

- https://github.com/godotengine/godot/issues/11841
  - follow SpatialEditorViewport::\_menu_option(VIEW_ORTHOGONAL) and see difference from real camera orthogonal projection
  - SpatialEditorViewport::orthogonal
  - SpatialEditorViewport::\_update_camera on NOTIFICATION_PROCESS

- particle: halo, strand (hair, fur)
  - https://docs.blender.org/manual/en/dev/physics/particles/introduction.html
  - https://docs.blender.org/manual/en/dev/physics/particles/hair/introduction.html
  - particle consists of frames of position within its lifespan (it can let physics simulation to produce that)
  - strand (hair) is represented as its path
  - hair modeling and rendering setup: https://www.youtube.com/watch?v=JysKjqKk8kw
  - strand geometric parameter: thickness, shape etc .. (it's cycle rendering time information though)
  - strand rendering parameter: bsdf https://docs.blender.org/manual/en/dev/render/cycles/nodes/types/shaders/hair.html

- hair in real time
  - non particle based one. polygonal (or card)
  - how do you get volumetric taste ?? (just rendering both faces ??)
  - anisotropic specular (is this from Kajiya-Key ?)
  - normal, diffuse, depth from texture ?? (maybe baked occlusion too ??)
  - modeling polygonal hair
      - https://bartoszstyperek.wordpress.com/2017/07/29/hair-tool-blender-addon/
      - https://www.youtube.com/watch?v=TAE01dIpS1o
  - https://en.wikipedia.org/wiki/Hair
  - Marschner: http://graphics.stanford.edu/papers/hair/
  - SIGGRAPH course: http://blog.selfshadow.com/publications/s2016-shading-course/karis/s2016_pbs_epic_hair.pdf
  - Kajiya & Key: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.127.5564
  - http://www.eugenedeon.com/project/an-energy-conserving-hair-reflectance-model/

- asset
  - https://www.textures.com/browse/substance/114546


# 2017-10-11

- godot particles
  - shader, rendering pipeline
  - do they contribute to shadow map ? yes, it can. Particles are just mesh with instancing within render_list.
  - particle behaviour calculation (particles.glsl with feedback executed in each frame)

```
[ Data structure ]

Particles < GeometryInstance (in 3d scene)
'-' emitting, amount ..
'-' ParticlesMaterial < Material (process_material)
  '-' shader RID ..
'-* Mesh (draw_passes)

Particles < GeometryOwner (in RasterizerStorageGLES3)
'-' (almost same members are copied to GLES3 layer too eg emitting, amount ..)


[ Procedure ]

- new PrimitiveMesh => RasterizerStorageGLES3::mesh_create => new Mesh

- new Particles =>
  - RasterizerStorageGLES3::particles_create => new Particles =>
    - glGenBuffers(.. particle_buffers) glGenVertexArrays(.. particle_vaos)

- Particles::set_draw_pass_mesh =>
  -  PrimitiveMesh::get_rid => _update =>
    - VisualServer::mesh_add_surface_from_arrays =>
      - RasterizerStorageGLES3::mesh_add_surface =>
        - new Surface
        - glGenBuffers(1, &surface->vertex_id), index_id, array_id, instancing_array_id ..
    - RasterizerStorageGLES3::mesh_surface_set_material

- RasterizerStorageGLES3::particles_set_amount =>
  - glBindVertexArray(.. particle_vaos)
  - glBindBuffer(.. particle_buffers)
  - setup vertex attributes

- RasterizerStorageGLES3::update_dirty_resources =>
  - update_particles =>
    - glEnable(GL_RASTERIZER_DISCARD)
    - iterate over particle_update_list
      - ParticlesShaderGLES3::bind (glsl shader program setup)
      - RasterizerStorageGLES3::_particles_process =>
        - glBindVertexArray(.. particle_vaos[0])
        - glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER .. particle_buffers[1])
        - glBeginTransformFeedback(GL_POINTS)
        - glDrawArrays(GL_POINTS, 0, p_particles->amount)
            feedback color, velocity, custom, xform, which will be
            the input of scene.glsl with USE_INSTANCING
            particle_buffers[0] is for input vertex attribute and obtain feedback into particle_buffers[1]
            and at the same time the previous result is used as particle_buffers[0]
        - glEndTransformFeedback()

- RasterizerSceneGLES3::_render_list =>
  - _fill_render_list =>
    - case VS::INSTANCE_PARTICLES
      - _add_geometry => ..
  - _setup_geometry =>
    - case VS::INSTANCE_PARTICLES
      - glBindVertexArray(s->instancing_array_id)
      - glBindBuffer(GL_ARRAY_BUFFER, particles->particle_buffers[0])
  - _render_geometry =>
    - case VS::INSTANCE_PARTICLES
      - glDrawElementsInstanced(.. amount)


[ particles.glsl + ParticlesMaterial's godot shader generation ]

float restart_phase = float(gl_VertexID)/float(total_particles)
```

# 2017-10-12

- flip vertically
  - https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/gl_FragCoord.xhtml
  - texelFetch (integer pixel coordinates)
  - textureLod (texture uv coordinates)
  - see glsl spec

# 2017-10-13

- c++ construction/destruction semantics
  - http://en.cppreference.com/w/cpp/language/rule_of_three
  - http://en.cppreference.com/w/cpp/language/copy_constructor
  - http://en.cppreference.com/w/cpp/language/copy_assignment
  - http://en.cppreference.com/w/cpp/language/move_constructor
  - http://en.cppreference.com/w/cpp/language/return

# 2017-10-14

- gdb
  - lldb got some unexpected behaviour so I switch to gdb fow now
    (lldb couldn't add breakpoint at ResourceImporterWebm::import)
  - https://sourceware.org/gdb/current/onlinedocs/gdb/index.html
  - execute program (run <arguments>)
  - breakpoint (br <function name>)
  - next line (n), step in (s), step out (finish (fin)), continue (c)
  - stack frame (bt, up, down)
  - toggle ui (C-x C-a)
  - variables information (info args, info locals, ptype, whatis, print (p))
  - step out of loop (until +2 or something)
  - thread selection (info threads, thread <id>)

- godot asset import system

```
[ Data structure ]

EditorFileSystem (constantly probe file system)
ImportDock (reimporting with parameter)
ResourceImporterWebm < ResourceImporter
ResourceFormatSaverBinary < ResourceFormatLoader

PropertyEditor < Control
'-' CustomPropertyEditor < Popup
  '-' EditorFileDialog


[ Procedure ]

(off-thread file scanning)
- EditorNode::_notification(NOTIFICATION_WM_FOCUS_IN) =>
  - EditorFileSystem::scan_changes =>
    - Thread::create(_thread_func_sources ..) --->
      - _scan_fs_changes recursively and accumulate scan_actions

(importing routine on main thread)
- EditorFileSystem::_notification(NOTIFICATION_PROCESS) =>
  - EditorFileSystem::_update_scan_actions => reimport_files, _reimport_file =>
    - ResourceFormatImporter::get_importer_by_name, get_importer_by_extension (here I assume .webm)
    - ResourceImporterWebm::get_import_options ..
    - ResourceFormatImporter::get_import_base_path (returns "res://.import/<filename>-<md5>")
    - ResourceImporterWebm::import =>
      - new VideoStreamWebm
      - ResourceSaver::save(res://.import/<filename>-<md5>.webmstr" ..) =>
        - probe savers (eg ResourceFormatSaverBinary, ResourceFormatSaverText ..)
        - ResourceFormatSaverBinary::save => ResourceFormatSaverBinaryInstance::save =>
          - save Resource's property (eg VideoStreamWebm's file, Resource's resource_path ..)
    - then save "<filename>.import" with importer name and import options ..

(loading asset (eg from PropertyEditor))
- PropertyEditor::_custom_editor_request =>
  - CustomPropertyEditor::edit => .. (eg show "New VideoStreamWebm" based on property hint)
  - CustomPropertyEditor::popup => ..

- CustomPropertyEditor::connect("id_pressed", this, "_menu_option") -->
  - CustomPropertyEditor::_menu_option => .. EditorFileDialog::popup_centered_ratio

- EditorFileDialog::connect("file_selected", this, "_file_selected") -->
  - CustomPropertyEditor::_file_selected =>
    - ResourceLoader::load("res://xxx.webm" ..) => _load => ResourceFormatImporter::load =>
      - _get_path_and_type (read "<filename>.import")
      - ResourceLoader::_load("res://.import/xxx.webm-...") => ResourceFormatLoader::load =>
        - ResourceFormatLoaderBinary::load_interactive => ..
        - then you'll get VideoStreamWebm with file property "res://llamigos-small.webm" ..
    - emit_signal("variant_changed")

- CustomPropertyEditor::connect("variant_changed", this, "_custom_editor_edited") -->
  - PropertyEditor::_custom_editor_edited => _edit_set => Resource::set ..
```

- [ ] godot video playback finish up
  - loop
  - seek
  - delay compensation

- [ ] godot visual programming system
  - data path, control path, game loop coordination (out of box as Node notifications in GDScript)
  - http://docs.godotengine.org/en/latest/learning/scripting/visual_script/visual_script_basics.html
  - compare with unreal blueprint https://docs.unrealengine.com/latest/INT/Engine/Blueprints/index.html


# Next time

- [ ] AR, VR
  - http://blogs.valvesoftware.com/abrash/why-virtual-isnt-real-to-your-brain/
  - http://blogs.valvesoftware.com/abrash/slides-from-my-game-developers-conference-talk/
  - lens distortion
  - AR background

- [ ] volumetric things in real time
  - frame, smoke, cloud
  - transmission, refraction

- [ ] soft body simulation
  - https://docs.blender.org/manual/en/dev/physics/soft_body/introduction.html#typical-scenarios-for-using-soft-bodies

- godot app export system

- try building these
  - https://gitlab.com/xonotic/xonotic
  - https://github.com/minetest/minetest

- buy
  - https://www.humblebundle.com/store/life-is-strange-complete-season   

- know some unreal's system
  - https://www.youtube.com/watch?v=QGIKrD7uHu8

- game dev experiment
  - [ ] first person shooter control
  - [ ] godot native module development
  - [ ] asset import from blender (mesh, skelton, animation, texture (diffuse, occlusion..))
  - [ ] bokeh post process

- [ ] lens, light continued
  - https://en.wikipedia.org/wiki/Lens_flare
  - https://en.wikipedia.org/wiki/Crepuscular_rays

- Write CV

- SIGGRAPH couse, papers
  - http://blog.selfshadow.com/publications/s2016-shading-course/karis/s2016_pbs_epic_hair.pdf
  - http://research.tri-ace.com/s2015.html

- Read Unreal rendering feature
  - https://docs.unrealengine.com/latest/INT/Engine/Rendering/index.html

- Read Unity rendering feature
  - https://docs.unity3d.com/Manual/Graphics.html

- Read armory rendering feature
  - http://forums.armory3d.org/t/build-12-is-out/424

- Godot shading techniques
  - copy back buffer (restricted region screen-space effect)

- libretro, emulator
  - https://www.libretro.com/index.php/getting-started-with-retroarch/
  - frontend example: https://github.com/libretro/RetroArch
  - core example: https://github.com/libretro/mupen64plus-libretro
  - content example: https://www.loveroms.com/roms/nintendo-64
  - dig into linux backend implementation
  - emulator architecture
      - http://mupen64plus.org/docs/
      - https://www.loveroms.com/roms/nintendo-64
      - file format

- Computer graphics
  - blender 2.8 viewport (eevee)
  - gpu feedback api
  - linux gpu driver implementation
  - linux gl implementation
  - volumetric

- tackle these
  - https://doomwiki.org/wiki/Doom_source_code
  - https://developer.nvidia.com/what-is-gameworks
  - https://github.com/nothings/stb/

- rust implementation
  - llvm binding in rust ?
  - module system (binary module)
  - type system
  - llvm in freestanding
