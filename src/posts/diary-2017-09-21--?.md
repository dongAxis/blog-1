<!--
{
  "title": "Diary (2017-09-21 -- ?)",
  "date": "2017-09-02T10:20:10+09:00",
  "special": true
}
-->

# 2017-09-21

- https://github.com/ocornut/imgui
  - sdl_opengl3_example
  - where does ui state live ? (selected, button click, mouse over, window position, scroll amount)
      - ImGuiContext (window, window position, window size, scroll, active, hover)
      - your app (what's being selected, what the text is)
  - is label of ui component used to identify state internally ?
      - seems so, ImHash(name) = ImGuiID
  - how could magically application code look immutable ?
      - carefully crafted with comparing between frame step sensitive state (like NextXXX, PrevXXX)
      - the fact that looping through (ImGui::NewFrame -> (your app) -> ImGui::Render) is fundamental architecture
      - it's still magic to me..
  - how is ui event handled ? (eg button click without creating stateful "button" object ?)

```
[ Data structure ]
ImGuiContext (static GImDefaultContext and its pointer GImGui)
'-' ImGuiIO
  '-' ..
'-* ImGuiWindow
  '-* ImDrawList
  '-* ImGuiDrawContext (used for widgets position tracking)
'-* ImGuiID (for active, hover, etc ..)


[ Proceder ]

- (static initializer)
  - ImGuiContext::ImGuiContext (for GImDefaultContext) => ..

- main =>
  - SDL_Init, SDL_CreateWindow, SDL_GL_CreateContext (platform window setup)
  - gl3wInit (gl call binding)
  - ImGui_ImplSdlGL3_Init =>
    - (setup ImGuiIO's vtable (eg RenderDrawListsFn, ImGui_ImplSdlGL3_SetClipboardText))
  - loop
    - SDL_PollEvent, ImGui_ImplSdlGL3_ProcessEvent =>
      - (temporary log all window events which will be normalized later)
    - ImGui_ImplSdlGL3_NewFrame =>
      - ImGui_ImplSdlGL3_CreateDeviceObjects (only for first time) =>
        - glCreateProgram with simple vertex_shader, fragment_shader ..
        - glGenBuffers for g_VboHandle, g_ElementsHandle and tell ImDrawVert's format
        - ImGui_ImplSdlGL3_CreateFontsTexture =>
          - ImFontAtlas::GetTexDataAsRGBA32 => ..
          - glGenTextures, glBindTexture, glTexImage2D (upload font data pixels)
      - (update ImGuiIO's fields (eg window size, frame tick, mousedown)
         based on what's found during ImGui_ImplSdlGL3_ProcessEvent)
      - ImGui::NewFrame =>
        - ImGui::Initialize =>
          - new ImGuiTextBuffer
          - LoadIniSettingsFromDisk => ..
        - SetCurrentFont
        - (update ImGuiContext (GImGui) fields (eg frame count))
          - frame count, reset OverlayDrawList, RenderDrawData
          - copy ui state as XXXPreviousFrame (eg HoveredIdPreviousFrame, ActiveIdPreviousFrame)
          - calculate ImGuiIO.MouseDelta by comparing with ImGuiIO.MousePosPrev
          - FocusWindow or ClearActiveID based on window existence (whether rendered on previous frame or not ?)
          - determine if mouse_avail_to_imgui based on something ?
          - move, scale, scroll window based on mouse event (how does scrool can contribute to scroll widget inside of the window ?)
          - reset all GImGui.Windows
          - ImGui::Begin("Debug##Default") =>
            - FindWindowByName or CreateNewWindow => new ImGuiWindow
            - window setup ..
    - ImGui::Button => ButtonEx =>
      - CalcItemSize, ItemSize
      - ItemAdd =>
        - IsMouseHoveringRect => (check with g.IO.MousePos)
      - ButtonBehavior =>
        - IsHovered => (check hover state based on global HoveredId and IsMouseHoveringRect)
        - if hovered, SetHoveredID
        - then check if hold or pressed using g.IO.MouseDown and g.IO.MouseDownDuration ..
        - then "pressed" is return value of ImGui::Button (so cool!)
      - RenderFrame => ImDrawList::AddRectFilled =>
        - PrimReserve(6, 4) (pare of # of indeces and verteces)
        - PrimRect => fille 6 entries into _IdxWritePtr and 4 entries into _VtxWritePtr
    - glViewport, glClearColor, glClear
    - ImGui::Render =>
      - EndFrame => End (pairing with ImGui::Begin("Debug##Default"))
      - (accumlate ImGuiContext::RenderDrawData (ImDrawData) from ImGuiWindow::DrawList (ImDrawList))
        - AddWindowToRenderListSelectLayer => AddWindowToRenderList(.. window->DrawList) => ..
      - (then pass it to RenderDrawListsFn) ImGui_ImplSdlGL3_RenderDrawLists =>
        - (backup gl's internal state so not to interfare with your real gl
           application code (eg GL_CURRENT_PROGRAM, GL_ACTIVE_TEXTURE))
        - glViewport, glUseProgram, ..
        - for each ImDrawList from ImDrawData::CmdLists,
          - glBindBuffer, glBufferData GL_ARRAY_BUFFER GL_ELEMENT_ARRAY_BUFFER (for ImDrawList::VtxBuffer, IdxBuffer)
          - for each ImDrawCmd from ImDrawList
            - glBindTexture(GL_TEXTURE_2D ..)
            - glScissor(.. ImDrawCmd::ClipRect ..)
            - glDrawElements(GL_TRIANGLES, ImDrawCmd::ElemCount..)
    - SDL_GL_SwapWindow
```


- Urho3D continued
  - see diary 2017-09-20
  - https://www.khronos.org/collada/
    "ossimp info Mutant.xml" isn't working ..

- https://github.com/bkaradzic/bgfx
  - random idea:
      - imgui, bgfx, lv2ui,


# Next time

- gl feature basics
  - scissor, alpha blend, face cull, depth test, glPolygonMode
  - stencil
  - vertex light

- tackle these
  - https://www.libretro.com/index.php/api/
  - https://github.com/bkaradzic/bgfx
      - platform window system abstraction?
      - graphics call abstraction?
  - https://doomwiki.org/wiki/Doom_source_code
  - https://github.com/nem0/lumixengine
  - https://developer.nvidia.com/what-is-gameworks
  - https://github.com/nothings/stb/

- rust implementation
  - llvm binding in rust ?
  - module system (binary module)
  - type system
  - llvm in freestanding
