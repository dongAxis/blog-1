<!--
{
  "title": "Diary (2017-09-21 -- ?)",
  "date": "2017-09-02T10:20:10+09:00",
  "special": true
}
-->

# 2017-09-21

- https://github.com/ocornut/imgui
  - sdl_opengl3_example
  - where does ui state live ? (selected, button click, mouse over, window position, scroll amount)
      - ImGuiContext (window, window position, window size, scroll, active, hover)
      - your app (what's being selected, what the text is)
  - is label of ui component used to identify state internally ?
      - seems so, ImHash(name) = ImGuiID
  - how could magically application code look immutable ?
      - carefully crafted with comparing between frame step sensitive state (like NextXXX, PrevXXX)
      - the fact that looping through (ImGui::NewFrame -> (your app) -> ImGui::Render) is fundamental architecture
      - it's still magic to me..
  - how is ui event handled ? (eg button click without creating stateful "button" object ?)

```
[ Data structure ]
ImGuiContext (static GImDefaultContext and its pointer GImGui)
'-' ImGuiIO
  '-' ..
'-* ImGuiWindow
  '-* ImDrawList
  '-* ImGuiDrawContext (used for widgets position tracking)
'-* ImGuiID (for active, hover, etc ..)


[ Proceder ]

- (static initializer)
  - ImGuiContext::ImGuiContext (for GImDefaultContext) => ..

- main =>
  - SDL_Init, SDL_CreateWindow, SDL_GL_CreateContext (platform window setup)
  - gl3wInit (gl call binding)
  - ImGui_ImplSdlGL3_Init =>
    - (setup ImGuiIO's vtable (eg RenderDrawListsFn, ImGui_ImplSdlGL3_SetClipboardText))
  - loop
    - SDL_PollEvent, ImGui_ImplSdlGL3_ProcessEvent =>
      - (temporary log all window events which will be normalized later)
    - ImGui_ImplSdlGL3_NewFrame =>
      - ImGui_ImplSdlGL3_CreateDeviceObjects (only for first time) =>
        - glCreateProgram with simple vertex_shader, fragment_shader ..
        - glGenBuffers for g_VboHandle, g_ElementsHandle and tell ImDrawVert's format
        - ImGui_ImplSdlGL3_CreateFontsTexture =>
          - ImFontAtlas::GetTexDataAsRGBA32 => ..
          - glGenTextures, glBindTexture, glTexImage2D (upload font data pixels)
      - (update ImGuiIO's fields (eg window size, frame tick, mousedown)
         based on what's found during ImGui_ImplSdlGL3_ProcessEvent)
      - ImGui::NewFrame =>
        - ImGui::Initialize =>
          - new ImGuiTextBuffer
          - LoadIniSettingsFromDisk => ..
        - SetCurrentFont
        - (update ImGuiContext (GImGui) fields (eg frame count))
          - frame count, reset OverlayDrawList, RenderDrawData
          - copy ui state as XXXPreviousFrame (eg HoveredIdPreviousFrame, ActiveIdPreviousFrame)
          - calculate ImGuiIO.MouseDelta by comparing with ImGuiIO.MousePosPrev
          - FocusWindow or ClearActiveID based on window existence (whether rendered on previous frame or not ?)
          - determine if mouse_avail_to_imgui based on something ?
          - move, scale, scroll window based on mouse event (how does scrool can contribute to scroll widget inside of the window ?)
          - reset all GImGui.Windows
          - ImGui::Begin("Debug##Default") =>
            - FindWindowByName or CreateNewWindow => new ImGuiWindow
            - window setup ..
    - ImGui::Button => ButtonEx =>
      - CalcItemSize, ItemSize
      - ItemAdd =>
        - IsMouseHoveringRect => (check with g.IO.MousePos)
      - ButtonBehavior =>
        - IsHovered => (check hover state based on global HoveredId and IsMouseHoveringRect)
        - if hovered, SetHoveredID
        - then check if hold or pressed using g.IO.MouseDown and g.IO.MouseDownDuration ..
        - then "pressed" is return value of ImGui::Button (so cool!)
      - RenderFrame => ImDrawList::AddRectFilled =>
        - PrimReserve(6, 4) (pare of # of indeces and verteces)
        - PrimRect => fille 6 entries into _IdxWritePtr and 4 entries into _VtxWritePtr
    - glViewport, glClearColor, glClear
    - ImGui::Render =>
      - EndFrame => End (pairing with ImGui::Begin("Debug##Default"))
      - (accumlate ImGuiContext::RenderDrawData (ImDrawData) from ImGuiWindow::DrawList (ImDrawList))
        - AddWindowToRenderListSelectLayer => AddWindowToRenderList(.. window->DrawList) => ..
      - (then pass it to RenderDrawListsFn) ImGui_ImplSdlGL3_RenderDrawLists =>
        - (backup gl's internal state so not to interfare with your real gl
           application code (eg GL_CURRENT_PROGRAM, GL_ACTIVE_TEXTURE))
        - glViewport, glUseProgram, ..
        - for each ImDrawList from ImDrawData::CmdLists,
          - glBindBuffer, glBufferData GL_ARRAY_BUFFER GL_ELEMENT_ARRAY_BUFFER (for ImDrawList::VtxBuffer, IdxBuffer)
          - for each ImDrawCmd from ImDrawList
            - glBindTexture(GL_TEXTURE_2D ..)
            - glScissor(.. ImDrawCmd::ClipRect ..)
            - glDrawElements(GL_TRIANGLES, ImDrawCmd::ElemCount..)
    - SDL_GL_SwapWindow
```


- Urho3D continued
  - see diary 2017-09-20
  - https://www.khronos.org/collada/
  -
    "ossimp info Mutant.xml" isn't working ..


# 2017-09-22

- Urho3D continued
  - see diary 2017-09-20
  - some backgrounds
      - http://www.opengl-tutorial.org (shadow map part is nice)
      - https://github.com/JoeyDeVries/LearnOpenGL
      - https://en.wikibooks.org/wiki/OpenGL_Programming
  - rendering:
      - clear, scenepass (base), forwardlights (light)
      - RenderPaths: Forward.xml
      - Materials: Stone.xml, Mushroom.xml, mutant_M.xml
      - Techniques: DiffNormal.xml (mutant, stone) , Diff.xml (mushroom)
      - Shaders: LitSolid.glsl, (Depth.glsl), (Shadow.glsl)
  - light, shadow


# 2017-09-23

- https://github.com/bkaradzic/bgfx
  - examples
      - platform window system abstraction in different thread
      - user app will be only a draw call generator
      - script to generate all platforms shaders (scripts/shader.mk)
  - graphics call abstraction
  - off-thread render mode and single threaded mode
  - view: how is the dependency between pass resolved (view, framebuffer, texture (eg deferred shading, shadow map)) ?
      - framebuffer0 -(createFrameBuffer)-> texture0 (or texture0 -(bgfx::getTexture)-> framebuffer0)
      - view0 -(setViewFrameBuffer)-> framebuffer0
      - view1 -(setTexture)-> texture0
  - default ascending view id. explicitly by setViewOrder https://bkaradzic.github.io/bgfx/bgfx.html#views

```
bgfx
'-' Frame (m_frame)
'-' Frame (m_render)
'-' RendererContextI ..

- bgfx::frame => frameNoRenderWait => swap =>
  - renderFrame => RendererContextI::submit => ??
    - ??

[ example ]


(entry_sdl.cpp)
- main => Context::run =>
  - SDL_Init, SDL_CreateWindow, ..
  - bx::Thread::init
  - loop, SDL_PollEvent and EventQueue::postXXX

(entry.cpp ..)
- MainThreadEntry::threadFunc => entry::main => _main_ (macro ENTRY_IMPLEMENT_MAIN) => runApp =>
  - ExampleShadowmapsSimple::init =>
    - bgfx::init => ??
    - bgfx::createUniform => ??
    - bgfx::getCaps => ??
    - bgfx::setUniform
    - bgfx::createVertexBuffer
    - loadProgram => ??
    - bgfx::createTexture2D
    - bgfx::createFrameBuffer
  - loop, ExampleShadowmapsSimple::update =>
    - entry::processEvents => ??
    - bgfx::setViewRect, setViewFrameBuffer, setViewTransform, setViewClear (gl's implicit statefulness is gone ??)
    - bgfx::submit(view_id ..) => ??
    -
```

- Computer graphics (OpenGL)
  - blend compositionality
      - light pass separation (seprate draw call for each light and simple add blend) (as in Urho3D light batches for each light)
  - scissor, alpha blend, face cull, depth test, stencil
  - vertex light (like normal map vs vertex normal interporation)
  - instancing: https://learnopengl.com/#!Advanced-OpenGL/Instancing
      - setup data to certain multiple of primitives (ie "instance")
      - can explicitly use in Urho3D with BillboardSet (not really, it's functionally same as putting several Nodes under one Node ?)
  - forward lighting, deferred lighting (shading)
      - https://gamedevelopment.tutsplus.com/articles/forward-rendering-vs-deferred-rendering--gamedev-12342
      - depth map should be enough to reproduce position information
      - Urho3D's lightvolumes render command (Defered.xml, DeferredLight.glsl)
        What primitive do you put for lightvolume drawing ? (some prepared geometries (Renderer::spotLightGeometry_ ..) are used)
        cf. "if defined(DEFERRED)" and "gl_FragData" in LitSolid.glsl
  - geometry shader: https://learnopengl.com/#!Advanced-OpenGL/Geometry-Shader
      - sounds simple

- Urho3D
  - renderpath Deferred.xml
      - gbuffer (short for geometry buffer, meaning "its shader output is not the final screen pixel color")
  - making geometry at far away from camera less visible (Zone's fogFactor (GetFogFactor in Fog.glsl))


# 2017-09-24

- https://github.com/bkaradzic/bgfx
  - know basic rendering techniques from examples
  - shadow volume
  - level of detail
  - scene light

- https://github.com/nem0/LumixEngine
  - it did build but editor didn't launch.
  - animation editor looks so cool https://www.youtube.com/watch?v=cKtBhmKVGdU

- godot engine
  - beautiful documentation!
  - engine architecture
      - http://docs.godotengine.org/en/latest/learning/step_by_step/scene_tree.html
      - http://docs.godotengine.org/en/latest/development/cpp/introduction_to_godot_development.html#architecture-diagram
      - http://docs.godotengine.org/en/latest/development/cpp/inheritance_class_tree.html
  - editor architecture
      - build option "tools" adds editor functionality, which turns on TOOLS_ENABLED macro.
      - when running game from editor, it will simply spawn godot without "--editor" argument with some IPC setup.
      - project list mode spawns "godot --path .. --editor"
      - editor is just EditorNode under root (Main::start => memnew(EditorNode) and get_root()->add_child)
      - 3d scene preview viewport within editor is SpatialEditorViewport (read spatial_editor_plugin.h,cpp)
        Scene's object (Spatial) is previewed via its SpatialEditorGizmo counterpart (eg MeshInstance -> MeshInstanceSpatialGizmo)
      - when in non-editor mode (ie normal gaming mode), your global and scene is loaded
        (see path (!project_manager_request && !editor) in Main::Start)
  - I would guess godot has very close architecture as qt (and qt creator).
  - rendering pipeline
      - not customizable but strong material parameter ?
        http://docs.godotengine.org/en/latest/learning/features/3d/spatial_material.html
      - shader code generation SpatialMaterial::\_update_shader

- misc
  - https://sketchfab.com/
  - http://docs.godotengine.org/en/latest/learning/features/3d/spatial_material.html
  - https://opengameart.org/
  - https://en.wikipedia.org/wiki/Ragdoll_physics
  - subsurface scattering
      - https://en.wikipedia.org/wiki/Subsurface_scattering
      - https://docs.blender.org/manual/en/dev/render/blender_render/materials/properties/subsurface_scattering.html
      - http://docs.godotengine.org/en/latest/learning/features/3d/spatial_material.html#subsurface-scattering


# 2017-09-25

- bgfx examples
  - build time shader generation
  - metaballs
      - https://en.wikipedia.org/wiki/Metaballs
      - http://paulbourke.net/geometry/polygonise/
      - is transient buffer bgfx level optimization ?
      - https://bkaradzic.github.io/bgfx/bgfx.html#_CPPv2N4bgfx26allocTransientVertexBufferEP21TransientVertexBuffer8uint32_tRK10VertexDecl
      - internally they could use subdata to reuse same buffer for different use
      - https://www.khronos.org/opengl/wiki/Buffer_Object
  - raymarch
      - http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm
      - distance function, ambient occlusion, fresnel
  - bump mapping
      - normal map (not subdivision surface displacement)

- ambient occlusion (ao)
  - https://en.wikipedia.org/wiki/Ambient_occlusion
  - convolution: [wiki](https://en.wikipedia.org/wiki/Kernel_(image_processing))
  - godot's ssao (drivers/gles3/shaders/ssao.glsl)

- conditional rendering
  - https://bkaradzic.github.io/bgfx/bgfx.html#conditional-rendering
  - https://www.khronos.org/opengl/wiki/Query_Object
  - https://www.khronos.org/opengl/wiki/Vertex_Rendering#Conditional_rendering

- global illumination
  - https://en.wikipedia.org/wiki/Global_illumination
  - [wiki](https://en.wikipedia.org/wiki/Radiosity_(computer_graphics))
  - http://research.nvidia.com/publication/interactive-indirect-illumination-using-voxel-cone-tracing
  - https://developer.nvidia.com/content/basics-gpu-voxelization
  - voxel
  - godot's GIProbe (scene.glsl gi_probes_compute)
  - wicked engine https://www.youtube.com/watch?v=siui7gLxcIQ

- texture
  - https://www.khronos.org/opengl/wiki/Texture
  - mipmap

- misc
  - parallax https://en.wikipedia.org/wiki/Parallax_scrolling
  - https://www.shadertoy.com/

- godot visual server
  - shader language
  - TODO: editor embeded 3d scene

```
$ lldb -- ./bin/godot.x11.tools.64.llvm --path ../godot-demo-projects/3d/platformer

[ Data structure ]
VisualServerWrapMT < VisualServer
'-' VisualServerRaster < VisualServer
  '-'

VisualServerViewport
'-* VisualServerViewport::Viewport (active viewports)
  '-' VisualServerScene::Scenario (as RID)
    '-' Octree<Instance, true>
      '-* VisualServerScene::Instance < RasterizerScene::InstanceBase
        '-' materials, light_instances, ..
        '-' aabb
        '-' VisualServerScene::InstanceBaseData (> InstanceGeometryData ..)
  '-' VisualServerScene::Camera (as RID)

ContextGL_X11 < ContextGL

RasterizerGLES3
'-' RasterizerStorageGLES3 < RasterizerStorage
  '-' ShaderCompilerGLES3 (TODO)
  '-' ParticlesShaderGLES3
'-' RasterizerSceneGLES3 < RasterizerScene < Rasterizer
  '-' SceneShaderGLES3 (build time. eg, drivers/gles3/shaders/scene.glsl.gen.h) < ShaderGLES3
  '-' SsaoShaderGLES3
'-' RasterizerCanvasGLES3 ..


OS_X11 < OS_Unix < OS
'-' SceneTree < MainLoop
  '-' Viewport (root)
    '-' ViewportTexture (default_texture)

MeshInstance < GeometryInstance < VisualInstance
'-' RID instance
'-* Material (eg SpatialMaterial, ShaderMaterial)

SpatialMaterial < Material
'-' Map<MaterialKey, ShaderData>
  '-* RID shader (as RasterizerStorageGLES3::Shader < RID_Data)
'-' RID material

RasterizerStorageGLES3::Shader
'-' VS::ShaderMode (eg "spatial")
'-' ShaderGLES3 (eg SceneShaderGLES3 (ie scene.glsl))
  '-' vertex_code, fragment_code
  '-' custom_defines
  '-* CustomCode
    '-' vertex, fragment ..
'-' code (godot shader code)

PackedScene < Resource
'-' SceneState < Reference
  '-* NodeData (type, name, properties)
  '-* ConnectionData


[ Proceduer ]

(Main path)
- main (platform/x11/godot_x11.cpp) =>
  - OS_X11 on stack
  - Main::setup =>
    - ..
    - ProjectSettings::setup =>
    - setup2 =>
      - OS_X11::initialize =>
        - XOpenDisplay
        - new ContextGL_X11, initialize => XCreateWindow, glXCreateContext ..
        - new VisualServerRaster => Rasterizer::create => new RasterizerGLES3
        - new VisualServerWrapMT
        - VisualServerWrapMT::init => VisualServerRaster::init => RasterizerGLES3::initialize =>
          - dlopen libGL
          - RasterizerStorageGLES3::initialize =>
            - some universal-use gl object initialization (eg default texture, screen quad, )
          - RasterizerSceneGLES3::initialize =>
            -
        - new PhysicsServerSW, init => ..
      - register_core_singletons => add project settings "OS", "Engine", etc ..
      - VisualServer::set_boot_image => ..
      - ..
  - Main::start =>
    - ClassDB::instance("SceneTree") => .. =>
      - new SceneTree =>
        - root = new Viewport =>
          - new World2D =>
            - VisualServer::canvas_create
            - Physics2DServer::space_create
          - VisualServerViewport::viewport_create =>
            - new VisualServerViewport::Viewport
            - RasterizerStorageGLES3::render_target_create => new RenderTarget, Texture
        - new World =>
          - PhysicsServerSW::space_create => ..
          - VisualServerScene::scenario_create =>
            - new Scenario
    - Ref<PackedScene> scenedata = ResourceLoader::load(local_game_path) => .. =>
      - ResourceInteractiveLoaderText::poll, get_resource (load scene and its sub resources recursively)
    - Node scene* = PackedScene::instance => SceneState::instance =>
      - for each node, ClassDB::instance ..
        (and possibly, PackedScene::instance recursively ..)
    - SceneTree::add_current_scene(scene)
    - OS_X11::set_main_loop
  - OS_X11::run =>
    - SceneTree::init =>
      - Node::_set_tree(this) => Node::_propagate_enter_tree ..
      - MainLoop::init
    - loop, process_xevents and Main::iteration =>
      - PhysicsServerSW::sync, flush_queries => ..
      - SceneTree::iteration =>
        - MainLoop::iteration =>
        - emit_signal("fixed_frame") ..
      - SceneTree::idle => ..
      - VisualServerWrapMT::draw => VisualServerRaster::draw =>
        - RasterizerStorageGLES3::update_dirty_resources
        - RasterizerSceneGLES3::iteration => update parameter
        - VisualServerScene::update_dirty_instances =>
          - _update_dirty_instance => _update_instance ..
        - VisualServerViewport::draw_viewports =>
          - sort_custom
          - iterate active_viewports
            - RasterizerGLES3::set_current_render_target => glViewport
            - _draw_viewport =>
              - VisualServerScene::render_camera =>
                - CameraMatrix::set_perspective
                - _render_scene =>
                  - (main part !!)
                  - Octree::cull_convex
                  - iterate culled Instance (ie light and geometry)
                  - ..
      - GDScriptLanguage::frame => ??

(Mesh instanciation)
- ClassDB::instance => .. => MeshInstance => GeometryInstance => VisualInstance =>
  - VisualServerScene::instance_create::instance_create => new Instance
  - VisualServerScene::instance_attach_object_instance_id ..

(Material/Shader instanciation)
- ResourceInteractiveLoaderText::poll => ClassDB::instance("SpatialMaterial") => .. =>
  - new SpatialMaterial =>
    - Material::Material =>
      - RasterizerStorageGLES3::material_create =>
        - new RasterizerStorageGLES3::Material

- SceneTree::_call_idle_callbacks => SpatialMaterial::flush_changes (static) =>
  - SpatialMaterial::_update_shader =>
    - RasterizerStorageGLES3::shader_create => new RasterizerStorageGLES3::Shader
    - RasterizerStorageGLES3::shader_set_code => ShaderGLES3::create_custom_shader
    - RasterizerStorageGLES3::material_set_shader => ..

- VisualServerRaster::draw => RasterizerGLES3::begin_frame => RasterizerStorageGLES3::update_dirty_resources =>
  - update_dirty_shaders => _update_shader =>
    - ShaderCompilerGLES3::GeneratedCode gen_code on stack
    - ShaderCompilerGLES3::compile =>
      - ShaderLanguage::compile => alloc_node<ShaderNode>, _parse_shader ..
      - _dump_node_code => some setup for uniform, vertex, fragement, light shader code ..
    - ShaderGLES3::set_custom_shader_code => ..

- VisualServerScene::_render_scene => RasterizerSceneGLES3::render_scene => _render_list => _setup_material =>
  - ShaderGLES3::bind =>
    - get_current_version =>
      - glCreateProgram, CreateShader, compile, link ..
    - glUseProgram
```


# 2017-09-26

- bgfx examples
  - hdr
      - skybox (as independent screen space single pass for background)
          - cube texture is sized for single face to fit screen (ie window size)
      - BGFX_INVALID_HANDLE is default back buffer (in this case, hdrHBlurTonemap)
      - post process in different color space (rgb, xyz, yxy)
      - blur
  - stencil
      - shadow or reflection on single geometry (in this case floor) by stencil
      - shadow: project meshes to ground with black fragment. light loop with blending
      - reflection:
      - obb (oriented bounding box, so not axis aligned)
      - how is stencil buffer constructed (for shadow case) ? it's saved on the same framebuffer with some special rule.
      - https://www.khronos.org/opengl/wiki/Stencil_Test
  - ibl (image based lighting)
      - this skybox doesn't distort depend on screen size. it always show vertically 45deg part of skybox.
      - radiance (aka explicit lod texture (aka mip level)), irradiance (given as texture)
      - https://www.khronos.org/opengl/wiki/Sampler_(GLSL)#Lod_texture_access
      - http://the-witness.net/news/2012/02/seamless-cube-map-filtering/
      - https://github.com/dariomanesku/cmft
      - irradiance for diffuse, mip texture (aka radiance) for specular
      - glossness affects mip level to use
      - workflow: glossy, metal, diffuse, specular (some pair is physically good visual characterization)
  - particle
      - ktx file (khronos texture) https://github.com/KhronosGroup/KTX
      - common/ps/particle_system..h,cpp
      - transient buffer, texture on to piramid mesh, alpha from particle lifetime
  - pom (parallax occlusion mapping)
      - pick normal from estimated uv coordinates from displacement (depth) map
      - fragment position (used for light direction) isn't modified in this way (cannot ?)

- Urho3D
  - water (23_Water)
      - slightly change uv coordinates to pick based on normal map for noise
      - mutate cached resource "Water.xml" with SetTexture(TU_DIFFUSE  <texture which reflection camera rendered on>)
      - refraction uses default viewport output as texture
  - smoke (07_Billboards)
      - smoke diffuse texture
      - face to view direction
      - direct light
      - not cast shadow (it could ? shadow map with alpha diffuse, assume smoke is sphere, etc ..)
      - alpha blend pass without writing depth (ie not contributing to depth test of others)
  - sdf shader (35_SignedDistanceFieldText)
  - decal (08_Decals)
      - Octree::RayCastSingle drawables (not bullet one)
      - determin part of mesh around hit point of drawable and calculate uv map via projection
      - hit drawable <- node -> decal set -> material
      - decal set -> decal -> verteces

# 2017-09-27

- Urho3D: multiplayer synchronization (17_SceneReplication)
  - transport protocol, appliation protocol
  - udp https://tools.ietf.org/html/rfc768
  - does "normal" NAT allow server to client udp packet ? (I think they can in the same way as tcp packet)
  - does kernel associate udp payload and application socket ?
      - for example, when two application (process) bind udp socket to same address/port.
        one application send packet to the address/port.
        which process does kernel route packet to ?
        I think there won't be routing and the first process calling recv will see a packet.
        application layer can (are supposed to) handle any situaion.
  - knet's udp packet handling (order, duplicates)
  - https://github.com/juj/kNet, http://clb.demon.fi/knet/

```
[ Data structure ]

(server)
Urho3D::Network < kNet::IMessageHandler, kNet::INetworkServerListener
'-' clientConnections_ (SERVER)
'-' networkScenes_     (SERVER)
'-' Connection         (CLIENT)

SceneReplication
'-' serverObjects_  (SERVER)
'-' clientObjectID_ (CLIENT)

Connection
'-' Controls
'-' SceneReplicationState


[ Procedure ]

(both setup)
- new Engine =>
  - new Network =>
    - new kNet::Network
    - SubscribeToEvent E_BEGINFRAME and E_RENDERUPDATE

- Network::RegisterRemoteEvent(E_CLIENTOBJECTID)

(server: start listening)
- SceneReplication::HandleStartServer => Network::StartServer =>
  - kNet::Network::StartServer =>
    - OpenListenSocket => socket, bind, listen ..
    - new NetworkServer, RegisterServerListener(.. $Urho3D::Network (as INetworkServerListener) ..)
    - AssignServerToWorkerThread => GetOrCreateWorkerThread ..

(client: connect initiation)
- SceneReplication::HandleConnect => Network::Connect =>
  - kNet::Network::Connect =>
    - ConnectSocket => socket, connect, getsockname, getpeername ..
    - SendUDPConnectDatagram => Socket::Send => send
    - new UDPMessageConnection(.. ConnectionPending), RegisterInboundMessageHandler(.. $Urho3D::Network (as IMessageHandler) ..)
    - AssignConnectionToWorkerThread
  - new Urho3D::Connection

(server network worker thread)
- NetworkWorkerThread::MainLoop => NetworkServer::ReadUDPSocketData =>
  - Socket::BeginReceive => Receive => recvfrom(.. (sockaddr*)&from )
  - if we've created UDPSlaveSocket for this "from" before, UDPMessageConnection::QueueInboundDatagram => ..
  - otherwise, EnqueueNewUDPConnectionAttempt => ..

(client network worker thread)
- NetworkWorkerThread::MainLoop => ..

(both: urho3D event cycle)
- Network::HandleBeginFrame => Update =>
  - (server) kNet::NetworkServer::Process =>
    - ProcessNewUDPConnectionAttempt =>
      - Urho3D::Network::NewConnectionAttempt => ..
      - pop udpConnectionAttempts and kNet::Network::CreateUDPSlaveSocket => ..
      - new UDPMessageConnection
      - Urho3D::Network::NewConnectionEstablished =>
        - UDPMessageConnection::RegisterInboundMessageHandler ..
        - new Urho3D::Connection
        - SendEvent(E_CLIENTCONNECTED ..) --> SceneReplication::HandleClientConnected =>
          - CreateControllableObject => add (replicated) ball node to scene
          - Connection::SendRemoteEvent(E_CLIENTOBJECTID ..) => queue remoteEvents_
      - MessageConnection::SendPingRequestMessage (NOTE: these are handled kNet layer (different from not exposed to application))
    - MessageConnection::Process for existing client connections => ..
  - (client)
    - kNet::MessageConnection::Process => Urho3D::Network::HandleMessage =>
      - Connection::ProcessMessage =>
        - switch by msgID. for example for MSG_CREATENODE, ProcessSceneUpdate =>
          - Scene::CreateChild(nodeID, REPLICATED), CreateComponent<SmoothedTransform>(LOCAL)
          - Node::CreateComponent(.. REPLICATED)
    - Urho3D::Connection::ProcessPendingLatestData => (handle out-of-order message about node)
    - OnServerConnected (successfule connection) =>
      - Connection::SendMessage(MSG_IDENTITY ..)
      - SendEvent(E_SERVERCONNECTED) --> ..

- Network::HandleRenderUpdate => PostUpdate -->
  - (server)
    - Scene::PrepareNetworkUpdate from client Connection::GetScene => PrepareNetworkUpdate for MarkNetworkUpdate nodes and components
    - Connection::SendServerUpdate => ProcessNode =>
      - ProcessNewNode => .. SendMessage(MSG_CREATENODE ..)
      - or ProcessExistingNode => .. SendMessage(MSG_NODEDELTAUPDATE ..) (MSG_REMOVECOMPONENT, MSG_COMPONENTLATESTDATA, ..)
    - Connection::SendRemoteEvents => .. SendMessage MSG_REMOTEEVENT, MSG_REMOTENODEEVENT
    - Connection::SendPackages => .. (static file upload)
  - (client)
    - Urho3D::Connection::SendClientUpdate => SendMessage(MSG_CONTROLS ..)
    - Urho3D::Connection::SendRemoteEvents => ..

- SceneReplication::HandlePhysicsPreStep =>
  - (client)
    - Controls on stack with current input state (yaw/forward/back/left/right)
    - Urho3D::Connection::SetControls
  - (server)
    - for each client connection, Connection::GetControls and RigidBody::ApplyTorque

- SceneReplication::HandlePostUpdate => MoveCamera => Camera::SetRotation
```

- Urho3D: enemy navigation (39_CrowdNavigation)
  - https://github.com/recastnavigation/recastnavigation
  - demo: solo mesh, nav_test.obj
  - navigation mesh construction: voxel, walkable voxel, raw contours, contours, navmesh
  - navigation mesh path finding: (TODO: read DetourCrowd)
  - streaming tiled navigation (dynamic navigation mesh update)
  - off mesh connection
  - how do you integrate with physics ? (ie what happens if node has CrowdAgent and RigidBody component ?)

```
[ Data structure ]
DynamicNavigationMesh < NavigationMesh
'-' dtNavMesh, dtNavMeshQuery, dtQueryFilter ..
'-' dtTileCache, dtTileCacheMeshProcess ..

CrowdManager
'-' dtCrowd
'-' NavigationMesh


[ Procedure ]

(Setup)
- CrowdNavigation::CreateScene =>
  - CreateComponent<DynamicNavigationMesh>
  - DynamicNavigationMesh::Build =>
    - NavigationMesh::CollectGeometries => recursively find geometries from navigable
    - dt api calls ..
  - CreateBoxOffMeshConnections =>
    - (box -> node on floor -> OffMeshConnection -> node on top of box)
  - CreateMushroom =>
    - (mushroom -> Obstacle (with radius and height))
    - .. => Obstacle::OnSceneSet => DynamicNavigationMesh::AddObstacle =>
      - dtTileCache::addObstacle ..
      - SendEvent(E_NAVIGATION_OBSTACLE_ADDED ..) -->
  - CreateComponent<CrowdManager>
  - SpawnJack =>
    - (jack -> CrowdAgent (with height, speed and acceleration))
    - .. => CrowdAgent::OnSceneSet => AddAgentToCrowd => CrowdManger::AddAgent =>
      - dtCrowd::addAgent ..

(Add agent's destination point)
- CrowdNavigation::SetPathPoint => CrowdManager::SetCrowdTarget =>
  - SendEvent(E_CROWD_AGENT_FORMATION, ..) -->
    - CrowdNavigation::HandleCrowdAgentFormation =>
      - CrowdManager::GetRandomPointInCircle (for non-first jacks)
  - CrowdAgent::SetTargetPosition => dtCrowd::requestMoveTarget ..


(Update handlers)
- CrowdManager::HandleSceneSubsystemUpdate =>
  - Update => dtCrowd::update .. -->
    - CrowdAgentUpdateCallback => CrowdUpdate::OnCrowdUpdate =>
      - SendEvent(E_CROWD_AGENT_REPOSITION ..) -->
        - CrowdNavigation::HandleCrowdAgentReposition =>
          - Node::SetRotation, AnimationController::Play, Stop based on agent velocity

- CrowdNavigation::UpdateStreaming =>
  - DynamicNavigationMesh::RemoveTile, AddTile to form tiles only around jack
```


# 2017-09-28

- godot visual server (see 2017-09-25)
  - [x] visual server, scene drawing
  - [x] material/shader setup (material, godot shader language setup, glsl setup)
  - [x] briefly go through scons build system
  - [x] link with lld "scons platform=x11 use_llvm=yes builtin_openssl=yes LINKFLAGS='-fuse-ld=lld'"
  - [x] editor embedded scene viewport
  - [ ] gdscript setup/execution (script_instance)
  - [ ] notification system (Node::\_notification ?)

```
[ Data structure ]
EditorNode
'-' Viewport (scene_root with set_disable_3d(true))
'-' EditorData
  '-* EditedScene
'-' EditorSelection
'-* EditorPlugin
'-' Control (called viewport)

SpatialEditorPlugin < EditorPlugin
'-' SpatialEditor < VBoxContainer
  '-' SpatialEditorViewportContainer < Container < Control < CanvasItem < Node
  '-* SpatialEditorViewport < Control
    '-' Control (surface)
    '-' EditorData
      '-' SpatialEditorGizmo
    '-' Camera
    '-' ViewportContainer (as Node child)
      '-' Viewport (with set_disable_input(true))
  '-' SpatialEditorGizmos

SpatialEditorGizmo < SpatialGizmo < Reference


[ Procedure ]
- Main::start => new EditorNode => new SpatialEditorPlugin =>
  - new SpatialEditor => new SpatialEditorViewport =>
    - new ViewportContainer, Viewport, Camera ..
  - Control::add_child($SpatialEditor)

(scene loading)
- FileSystemDock::_select_file => EditorNode::open_request => load_scene =>
  - Ref<PackedScene> sdata = ResourceLoader::load
  - Node *new_scene = sdata->instance
  - new_scene->set_scene_instance_state
  - set_edited_scene =>
    - EditorData::set_edited_scene_root
    - SceneTreeDock::set_edited_scene
    - SceneTree::set_edited_scene_root
    - scene_root->add_child (scene_root is Viewport)

- EditorNode::_set_main_scene_state (some callback) =>
  - _editor_select(EDITOR_3D) =>
    - SpatialEditorPlugin::make_visible =>
      - CanvasItem::show (ie SpatialEditor)
  - EditorData::notify_edited_scene_changed => ..

- SpatialEditor::_request_gizmo (some callback) =>
  - SpatialEditorGizmos::get_gizmo ..

(viewport)
- Viewport::_notification =>
  - case NOTIFICATION_ENTER_TREE
    - TODO: this gets SpatialEditorViewport's Viewport gets currently
            focused Scene's world with that scenario ??
    - VisualServerViewport::viewport_set_scenario =>
```

- Godot 2d drawing system
  - following this problem https://github.com/godotengine/godot/issues/11533

```
(main path)
- SceneTree::iteration => MessageQueue::flush => .. => CanvasItem::_update_callback =>
  - Object::notification(NOTIFICATION_DRAW) => Line2D::_notification => _draw ..

- CanvasItem::CanvasItem =>
  - VisualServerCanvas::canvas_item_create

(draw implementation)
- Line2D::_draw =>
  - LineBuilder::build => ..
  - VisualServerCanvas::canvas_item_add_triangle_array(canvas item RID, primitive infos (ie verteces, index, tex ..))
```


# 2017-09-29

- godot gdscript
  - extends, binding, callbacks
  - c++ to gdscript (eg standard notification ("\_ready", "\_fixed_process"))
  - gdscript to c++ (eg instance method call ("get_node", "connect" from gdscript))

- godot message, notification
  - signal, slot (eg BaseButton::\_gui_input => emit_signal("pressed"))
  - notification (NOTIFICATION_XXX enum in node.h)

```
[ Example scene (textual) ]

    [gd_scene load_steps=2 format=2]

    [ext_resource path="res://test-2d.gd" type="Script" id=1]

    [node name="Panel" type="Panel"]

    anchor_left = 0.0
    anchor_top = 0.0
    anchor_right = 0.0
    anchor_bottom = 0.0
    margin_right = 187.0
    margin_bottom = 127.0
    rect_pivot_offset = Vector2( 0, 0 )
    rect_clip_content = false
    mouse_filter = 0
    size_flags_horizontal = 1
    size_flags_vertical = 1
    script = ExtResource( 1 )

    ...


[ Data structure ]
GDScriptLanguage < ScriptLanguage

Object
'-' GDInstance < ScriptInstance
  '-' GDScript < Script < Resource
    '-' constants, functions .. (single GDScript corresponds to class definition)


[ Procedure ]
- Main::setup, setup2 => register_module_types => register_gdscript_types =>
  - ScriptServer::register_language($GDScriptLanguage) ..

- Main::start =>
  - ResourceLoader::load => .. =>
    - ResourceFormatLoaderGDScript::load =>
      - new GDScript
      - GDScript::load_source_code, reload =>
        - GDParser::parse => ..
        - GDCompiler::compile($GDParser, $GDScript ..) => _parse_class ..
  - PackedScene::instance => .. =>
    - Object::set_script => GDScript::instance_create($Object) => _create_instance =>
      - new GDInstance
      - Object::set_script_instance($GDInstance)
      - call _init ..


[ Binding setup ]
- Node::_bind_methods =>
  - ClassDB::bind_method(D_METHOD("get_node", "path"), &Node::get_node) =>
    - create_method_bind ..
    - bind_methodfi
  - BIND_VMETHOD(MethodInfo("_fixed_process", PropertyInfo(Variant::REAL, "delta"))) (for tooling )

(call from gdscript)
- GDFunction::call =>
  - OPCODE_CALL -> Variant::call_ptr => Object::call =>
    - ScriptInstance::call or ClassDB::get_method, MethodBind::call
  - OPCODE_CALL_BUILT_IN -> GDFunctions::call builtin
  - OPCODE_CALL_SELF_BASE ->
    - find method and GDFunction::call recursively
    - or ClassDB::get_method, MethodBind::call
  - ..


[ Event system ]
(node notification)
- Node::notification (ie Object::notification) =>
  - Node::_notificationv (macro from GDCLASS(Node, Object)) =>
    - Node::_notification =>
      - case NOTIFICATION_FIXED_PROCESS, GDInstance::call_multilevel("_fixed_process") ..
  - GDInstance::notification => call "_notification" GDFunction if it exists

(example: instanciation)
- PackedScene::instance => Node::notification(Node::NOTIFICATION_INSTANCED)

(example: gui signal)
- BaseButton::_gui_input => emit_signal("pressed") => ..
```


- godot platformer example
  - gridmap
  - area (audio, collision)
  - reflection probe
  - kinematic body (Input)
  - 3d character animation, skelton (bones), animation player, animation tree player



# Next time

- libretro, emulator
  - https://www.libretro.com/index.php/getting-started-with-retroarch/
  - frontend example: https://github.com/libretro/RetroArch
  - core example: https://github.com/libretro/mupen64plus-libretro
  - content example: https://www.loveroms.com/roms/nintendo-64
  - dig into linux backend implementation
  - emulator architecture
      - http://mupen64plus.org/docs/
      - https://www.loveroms.com/roms/nintendo-64
      - file format

- Computer graphics
  - volumetric light: https://en.wikipedia.org/wiki/Volumetric_lighting
  - blender 2.8 viewport (eevee)
  - gpu feedback api
  - linux gpu driver implementation
  - linux gl implementation
  - gl memory management (gl buffer data update)
  - height map (with physics)
  - subsurface scattering
  - emission
  - sponza scene: http://www.crytek.com/cryengine/cryengine3/downloads/
  - https://github.com/ashima/webgl-noise/wiki
  - https://github.com/KhronosGroup/glTF
  - shader for skinning
  - PBR (procedual, raster), volume (smoke), emission


- tackle these
  - https://www.libretro.com/index.php/api/
  - https://doomwiki.org/wiki/Doom_source_code
  - https://developer.nvidia.com/what-is-gameworks
  - https://github.com/nothings/stb/

- rust implementation
  - llvm binding in rust ?
  - module system (binary module)
  - type system
  - llvm in freestanding
