<!--
{
  "title": "Diary (2017-09-21 -- ?)",
  "date": "2017-09-02T10:20:10+09:00",
  "special": true
}
-->

# 2017-09-21

- https://github.com/ocornut/imgui
  - sdl_opengl3_example
  - where does ui state live ? (selected, button click, mouse over, window position, scroll amount)
      - ImGuiContext (window, window position, window size, scroll, active, hover)
      - your app (what's being selected, what the text is)
  - is label of ui component used to identify state internally ?
      - seems so, ImHash(name) = ImGuiID
  - how could magically application code look immutable ?
      - carefully crafted with comparing between frame step sensitive state (like NextXXX, PrevXXX)
      - the fact that looping through (ImGui::NewFrame -> (your app) -> ImGui::Render) is fundamental architecture
      - it's still magic to me..
  - how is ui event handled ? (eg button click without creating stateful "button" object ?)

```
[ Data structure ]
ImGuiContext (static GImDefaultContext and its pointer GImGui)
'-' ImGuiIO
  '-' ..
'-* ImGuiWindow
  '-* ImDrawList
  '-* ImGuiDrawContext (used for widgets position tracking)
'-* ImGuiID (for active, hover, etc ..)


[ Proceder ]

- (static initializer)
  - ImGuiContext::ImGuiContext (for GImDefaultContext) => ..

- main =>
  - SDL_Init, SDL_CreateWindow, SDL_GL_CreateContext (platform window setup)
  - gl3wInit (gl call binding)
  - ImGui_ImplSdlGL3_Init =>
    - (setup ImGuiIO's vtable (eg RenderDrawListsFn, ImGui_ImplSdlGL3_SetClipboardText))
  - loop
    - SDL_PollEvent, ImGui_ImplSdlGL3_ProcessEvent =>
      - (temporary log all window events which will be normalized later)
    - ImGui_ImplSdlGL3_NewFrame =>
      - ImGui_ImplSdlGL3_CreateDeviceObjects (only for first time) =>
        - glCreateProgram with simple vertex_shader, fragment_shader ..
        - glGenBuffers for g_VboHandle, g_ElementsHandle and tell ImDrawVert's format
        - ImGui_ImplSdlGL3_CreateFontsTexture =>
          - ImFontAtlas::GetTexDataAsRGBA32 => ..
          - glGenTextures, glBindTexture, glTexImage2D (upload font data pixels)
      - (update ImGuiIO's fields (eg window size, frame tick, mousedown)
         based on what's found during ImGui_ImplSdlGL3_ProcessEvent)
      - ImGui::NewFrame =>
        - ImGui::Initialize =>
          - new ImGuiTextBuffer
          - LoadIniSettingsFromDisk => ..
        - SetCurrentFont
        - (update ImGuiContext (GImGui) fields (eg frame count))
          - frame count, reset OverlayDrawList, RenderDrawData
          - copy ui state as XXXPreviousFrame (eg HoveredIdPreviousFrame, ActiveIdPreviousFrame)
          - calculate ImGuiIO.MouseDelta by comparing with ImGuiIO.MousePosPrev
          - FocusWindow or ClearActiveID based on window existence (whether rendered on previous frame or not ?)
          - determine if mouse_avail_to_imgui based on something ?
          - move, scale, scroll window based on mouse event (how does scrool can contribute to scroll widget inside of the window ?)
          - reset all GImGui.Windows
          - ImGui::Begin("Debug##Default") =>
            - FindWindowByName or CreateNewWindow => new ImGuiWindow
            - window setup ..
    - ImGui::Button => ButtonEx =>
      - CalcItemSize, ItemSize
      - ItemAdd =>
        - IsMouseHoveringRect => (check with g.IO.MousePos)
      - ButtonBehavior =>
        - IsHovered => (check hover state based on global HoveredId and IsMouseHoveringRect)
        - if hovered, SetHoveredID
        - then check if hold or pressed using g.IO.MouseDown and g.IO.MouseDownDuration ..
        - then "pressed" is return value of ImGui::Button (so cool!)
      - RenderFrame => ImDrawList::AddRectFilled =>
        - PrimReserve(6, 4) (pare of # of indeces and verteces)
        - PrimRect => fille 6 entries into _IdxWritePtr and 4 entries into _VtxWritePtr
    - glViewport, glClearColor, glClear
    - ImGui::Render =>
      - EndFrame => End (pairing with ImGui::Begin("Debug##Default"))
      - (accumlate ImGuiContext::RenderDrawData (ImDrawData) from ImGuiWindow::DrawList (ImDrawList))
        - AddWindowToRenderListSelectLayer => AddWindowToRenderList(.. window->DrawList) => ..
      - (then pass it to RenderDrawListsFn) ImGui_ImplSdlGL3_RenderDrawLists =>
        - (backup gl's internal state so not to interfare with your real gl
           application code (eg GL_CURRENT_PROGRAM, GL_ACTIVE_TEXTURE))
        - glViewport, glUseProgram, ..
        - for each ImDrawList from ImDrawData::CmdLists,
          - glBindBuffer, glBufferData GL_ARRAY_BUFFER GL_ELEMENT_ARRAY_BUFFER (for ImDrawList::VtxBuffer, IdxBuffer)
          - for each ImDrawCmd from ImDrawList
            - glBindTexture(GL_TEXTURE_2D ..)
            - glScissor(.. ImDrawCmd::ClipRect ..)
            - glDrawElements(GL_TRIANGLES, ImDrawCmd::ElemCount..)
    - SDL_GL_SwapWindow
```


- Urho3D continued
  - see diary 2017-09-20
  - https://www.khronos.org/collada/
  -
    "ossimp info Mutant.xml" isn't working ..


# 2017-09-22

- Urho3D continued
  - see diary 2017-09-20
  - some backgrounds
      - http://www.opengl-tutorial.org (shadow map part is nice)
      - https://github.com/JoeyDeVries/LearnOpenGL
      - https://en.wikibooks.org/wiki/OpenGL_Programming
  - rendering:
      - clear, scenepass (base), forwardlights (light)
      - RenderPaths: Forward.xml
      - Materials: Stone.xml, Mushroom.xml, mutant_M.xml
      - Techniques: DiffNormal.xml (mutant, stone) , Diff.xml (mushroom)
      - Shaders: LitSolid.glsl, (Depth.glsl), (Shadow.glsl)
  - light, shadow


# 2017-09-23

- https://github.com/bkaradzic/bgfx
  - examples
      - platform window system abstraction in different thread
      - user app will be only a draw call generator
      - script to generate all platforms shaders (scripts/shader.mk)
  - graphics call abstraction
  - off-thread render mode and single threaded mode
  - view: how is the dependency between pass resolved (view, framebuffer, texture (eg deferred shading, shadow map)) ?
      - framebuffer0 -(createFrameBuffer)-> texture0 (or texture0 -(bgfx::getTexture)-> framebuffer0)
      - view0 -(setViewFrameBuffer)-> framebuffer0
      - view1 -(setTexture)-> texture0
  - default ascending view id. explicitly by setViewOrder https://bkaradzic.github.io/bgfx/bgfx.html#views

```
bgfx
'-' Frame (m_frame)
'-' Frame (m_render)
'-' RendererContextI ..

- bgfx::frame => frameNoRenderWait => swap =>
  - renderFrame => RendererContextI::submit => ??
    - ??

[ example ]


(entry_sdl.cpp)
- main => Context::run =>
  - SDL_Init, SDL_CreateWindow, ..
  - bx::Thread::init
  - loop, SDL_PollEvent and EventQueue::postXXX

(entry.cpp ..)
- MainThreadEntry::threadFunc => entry::main => _main_ (macro ENTRY_IMPLEMENT_MAIN) => runApp =>
  - ExampleShadowmapsSimple::init =>
    - bgfx::init => ??
    - bgfx::createUniform => ??
    - bgfx::getCaps => ??
    - bgfx::setUniform
    - bgfx::createVertexBuffer
    - loadProgram => ??
    - bgfx::createTexture2D
    - bgfx::createFrameBuffer
  - loop, ExampleShadowmapsSimple::update =>
    - entry::processEvents => ??
    - bgfx::setViewRect, setViewFrameBuffer, setViewTransform, setViewClear (gl's implicit statefulness is gone ??)
    - bgfx::submit(view_id ..) => ??
    -
```

- Computer graphics (OpenGL)
  - blend compositionality
      - light pass separation (seprate draw call for each light and simple add blend) (as in Urho3D light batches for each light)
  - scissor, alpha blend, face cull, depth test, stencil
  - vertex light (like normal map vs vertex normal interporation)
  - instancing: https://learnopengl.com/#!Advanced-OpenGL/Instancing
      - setup data to certain multiple of primitives (ie "instance")
      - can explicitly use in Urho3D with BillboardSet (not really, it's functionally same as putting several Nodes under one Node ?)
  - forward lighting, deferred lighting (shading)
      - https://gamedevelopment.tutsplus.com/articles/forward-rendering-vs-deferred-rendering--gamedev-12342
      - depth map should be enough to reproduce position information
      - Urho3D's lightvolumes render command (Defered.xml, DeferredLight.glsl)
        What primitive do you put for lightvolume drawing ? (some prepared geometries (Renderer::spotLightGeometry_ ..) are used)
        cf. "if defined(DEFERRED)" and "gl_FragData" in LitSolid.glsl
  - geometry shader: https://learnopengl.com/#!Advanced-OpenGL/Geometry-Shader
      - sounds simple

- Urho3D
  - renderpath Deferred.xml
      - gbuffer (short for geometry buffer, meaning "its shader output is not the final screen pixel color")
  - making geometry at far away from camera less visible (Zone's fogFactor (GetFogFactor in Fog.glsl))


# 2017-09-24

- https://github.com/bkaradzic/bgfx
  - know basic rendering techniques from examples
  - shadow volume
  - level of detail
  - scene light

- https://github.com/nem0/LumixEngine
  - it did build but editor didn't launch.
  - animation editor looks so cool https://www.youtube.com/watch?v=cKtBhmKVGdU

- godot engine
  - beautiful documentation!
  - engine architecture
      - http://docs.godotengine.org/en/latest/learning/step_by_step/scene_tree.html
      - http://docs.godotengine.org/en/latest/development/cpp/introduction_to_godot_development.html#architecture-diagram
      - http://docs.godotengine.org/en/latest/development/cpp/inheritance_class_tree.html
  - editor architecture
      - build option "tools" adds editor functionality, which turns on TOOLS_ENABLED macro.
      - when running game from editor, it will simply spawn godot without "--editor" argument with some IPC setup.
      - project list mode spawns "godot --path .. --editor"
      - editor is just EditorNode under root (Main::start => memnew(EditorNode) and get_root()->add_child)
      - 3d scene preview viewport within editor is SpatialEditorViewport (read spatial_editor_plugin.h,cpp)
        Scene's object (Spatial) is previewed via its SpatialEditorGizmo counterpart (eg MeshInstance -> MeshInstanceSpatialGizmo)
      - when in non-editor mode (ie normal gaming mode), your global and scene is loaded
        (see path (!project_manager_request && !editor) in Main::Start)
  - I would guess godot has very close architecture as qt (and qt creator).
  - rendering pipeline
      - not customizable but strong material parameter ?
        http://docs.godotengine.org/en/latest/learning/features/3d/spatial_material.html
      - shader code generation SpatialMaterial::\_update_shader

- misc
  - https://sketchfab.com/
  - http://docs.godotengine.org/en/latest/learning/features/3d/spatial_material.html
  - https://opengameart.org/
  - https://en.wikipedia.org/wiki/Ragdoll_physics
  - subsurface scattering
      - https://en.wikipedia.org/wiki/Subsurface_scattering
      - https://docs.blender.org/manual/en/dev/render/blender_render/materials/properties/subsurface_scattering.html
      - http://docs.godotengine.org/en/latest/learning/features/3d/spatial_material.html#subsurface-scattering


# 2017-09-25

- bgfx examples
  - build time shader generation
  - metaballs
      - https://en.wikipedia.org/wiki/Metaballs
      - http://paulbourke.net/geometry/polygonise/
      - is transient buffer bgfx level optimization ?
      - https://bkaradzic.github.io/bgfx/bgfx.html#_CPPv2N4bgfx26allocTransientVertexBufferEP21TransientVertexBuffer8uint32_tRK10VertexDecl
      - internally they could use subdata to reuse same buffer for different use
      - https://www.khronos.org/opengl/wiki/Buffer_Object
  - raymarch
      - http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm
      - distance function, ambient occlusion, fresnel
  - bump mapping
      - normal map (not subdivision surface displacement)

- ambient occlusion (ao)
  - https://en.wikipedia.org/wiki/Ambient_occlusion
  - convolution: [wiki](https://en.wikipedia.org/wiki/Kernel_(image_processing))
  - godot's ssao (drivers/gles3/shaders/ssao.glsl)

- conditional rendering
  - https://bkaradzic.github.io/bgfx/bgfx.html#conditional-rendering
  - https://www.khronos.org/opengl/wiki/Query_Object
  - https://www.khronos.org/opengl/wiki/Vertex_Rendering#Conditional_rendering

- global illumination
  - https://en.wikipedia.org/wiki/Global_illumination
  - [wiki](https://en.wikipedia.org/wiki/Radiosity_(computer_graphics))
  - http://research.nvidia.com/publication/interactive-indirect-illumination-using-voxel-cone-tracing
  - https://developer.nvidia.com/content/basics-gpu-voxelization
  - voxel
  - godot's GIProbe (scene.glsl gi_probes_compute)
  - wicked engine https://www.youtube.com/watch?v=siui7gLxcIQ

- texture
  - https://www.khronos.org/opengl/wiki/Texture
  - mipmap

- misc
  - parallax https://en.wikipedia.org/wiki/Parallax_scrolling
  - https://www.shadertoy.com/

- godot visual server
  - shader language

```
[ Data structure ]
VisualServerWrapMT < VisualServer

RasterizerStorageGLES3 < RasterizerStorage
'-' RasterizerSceneGLES3

Scene

MeshInstance < GeometryInstance
'-* Material (eg SpatialMaterial, ShaderMaterial)

SpatialMaterial
'-' Map<MaterialKey, ShaderData>
  '-' RID (shader)

Shader < Resource
'-'

SceneShaderGLES3 (build time. eg, drivers/gles3/shaders/scene.glsl.gen.h) < ShaderGLES3


[ Proceduer ]
- SceneTree::_call_idle_callbacks => SpatialMaterial::flush_changes =>
  - SpatialMaterial::_update_shader =>
    - RasterizerStorageGLES3::shader_create => new RasterizerStorageGLES3::Shader
    - RasterizerStorageGLES3::shader_set_code =>
      - read "shader_type" (eg VS::SHADER_SPATIAL)
      - ShaderGLES3::create_custom_shader => ??
    - RasterizerStorageGLES3::material_set_shader => ??
```


# 2017-09-26

- bgfx examples
  - hdr
      - skybox (as independent screen space single pass for background)
          - cube texture is sized for single face to fit screen (ie window size)
      - BGFX_INVALID_HANDLE is default back buffer (in this case, hdrHBlurTonemap)
      - post process in different color space (rgb, xyz, yxy)
      - blur
  - stencil
      - shadow or reflection on single geometry (in this case floor) by stencil
      - shadow: project meshes to ground with black fragment. light loop with blending
      - reflection:
      - obb (oriented bounding box, so not axis aligned)
      - how is stencil buffer constructed (for shadow case) ? it's saved on the same framebuffer with some special rule.
      - https://www.khronos.org/opengl/wiki/Stencil_Test
  - ibl (image based lighting)
      - this skybox doesn't distort depend on screen size. it always show vertically 45deg part of skybox.
      - radiance (aka explicit lod texture (aka mip level)), irradiance (given as texture)
      - https://www.khronos.org/opengl/wiki/Sampler_(GLSL)#Lod_texture_access
      - http://the-witness.net/news/2012/02/seamless-cube-map-filtering/
      - https://github.com/dariomanesku/cmft
      - irradiance for diffuse, mip texture (aka radiance) for specular
      - glossness affects mip level to use
      - workflow: glossy, metal, diffuse, specular (some pair is physically good visual characterization)
  - particle
      - ktx file (khronos texture) https://github.com/KhronosGroup/KTX
      - common/ps/particle_system..h,cpp
      - transient buffer, texture on to piramid mesh, alpha from particle lifetime
  - pom (parallax occlusion mapping)
      - pick normal from estimated uv coordinates from displacement (depth) map
      - fragment position (used for light direction) isn't modified in this way (cannot ?)

- Urho3D
  - water (23_Water)
      - slightly change uv coordinates to pick based on normal map for noise
      - mutate cached resource "Water.xml" with SetTexture(TU_DIFFUSE  <texture which reflection camera rendered on>)
      - refraction uses default viewport output as texture
  - smoke (07_Billboards)
      - smoke diffuse texture
      - face to view direction
      - direct light
      - not cast shadow (it could ? shadow map with alpha diffuse, assume smoke is sphere, etc ..)
      - alpha blend pass without writing depth (ie not contributing to depth test of others)
  - sdf shader (35_SignedDistanceFieldText)
  - decal (08_Decals)
      - Octree::RayCastSingle drawables (not bullet one)
      - determin part of mesh around hit point of drawable and calculate uv map via projection
      - hit drawable <- node -> decal set -> material
      - decal set -> decal -> verteces

# 2017-09-27

- Urho3D
  - multiplayer synchronization (17_SceneReplication)
      - transport protocol, appliation protocol
      - udp https://tools.ietf.org/html/rfc768
      - does "normal" NAT allow server to client udp packet ? (I think they can in the same way as tcp packet)
      - does kernel associate udp payload and application socket ?
          - for example, when two application (process) bind udp socket to same address/port.
            one application send packet to the address/port.
            which process does kernel route packet to ?
            I think there won't be routing and the first process calling recv will see a packet.
            application layer can (are supposed to) handle any situaion.
      - knet's udp packet handling (order, duplicates)

```
[ Data structure ]

(server)
Urho3D::Network < kNet::IMessageHandler, kNet::INetworkServerListener
'-' clientConnections_ (SERVER)
'-' networkScenes_     (SERVER)
'-' Connection         (CLIENT)

SceneReplication
'-' serverObjects_  (SERVER)
'-' clientObjectID_ (CLIENT)

Connection
'-' Controls
'-' SceneReplicationState


[ Procedure ]

(both setup)
- new Engine =>
  - new Network =>
    - new kNet::Network
    - SubscribeToEvent E_BEGINFRAME and E_RENDERUPDATE

- Network::RegisterRemoteEvent(E_CLIENTOBJECTID)

(server: start listening)
- SceneReplication::HandleStartServer => Network::StartServer =>
  - kNet::Network::StartServer =>
    - OpenListenSocket => socket, bind, listen ..
    - new NetworkServer, RegisterServerListener(.. $Urho3D::Network (as INetworkServerListener) ..)
    - AssignServerToWorkerThread => GetOrCreateWorkerThread ..

(client: connect initiation)
- SceneReplication::HandleConnect => Network::Connect =>
  - kNet::Network::Connect =>
    - ConnectSocket => socket, connect, getsockname, getpeername ..
    - SendUDPConnectDatagram => Socket::Send => send
    - new UDPMessageConnection(.. ConnectionPending), RegisterInboundMessageHandler(.. $Urho3D::Network (as IMessageHandler) ..)
    - AssignConnectionToWorkerThread
  - new Urho3D::Connection

(server network worker thread)
- NetworkWorkerThread::MainLoop => NetworkServer::ReadUDPSocketData =>
  - Socket::BeginReceive => Receive => recvfrom(.. (sockaddr*)&from )
  - if we've created UDPSlaveSocket for this "from" before, UDPMessageConnection::QueueInboundDatagram => ..
  - otherwise, EnqueueNewUDPConnectionAttempt => ..

(client network worker thread)
- NetworkWorkerThread::MainLoop => ..

(both: urho3D event cycle)
- Network::HandleBeginFrame => Update =>
  - (server) kNet::NetworkServer::Process =>
    - ProcessNewUDPConnectionAttempt =>
      - Urho3D::Network::NewConnectionAttempt => ..
      - pop udpConnectionAttempts and kNet::Network::CreateUDPSlaveSocket => ..
      - new UDPMessageConnection
      - Urho3D::Network::NewConnectionEstablished =>
        - UDPMessageConnection::RegisterInboundMessageHandler ..
        - new Urho3D::Connection
        - SendEvent(E_CLIENTCONNECTED ..) --> SceneReplication::HandleClientConnected =>
          - CreateControllableObject => add (replicated) ball node to scene
          - Connection::SendRemoteEvent(E_CLIENTOBJECTID ..) => queue remoteEvents_
      - MessageConnection::SendPingRequestMessage (NOTE: these are handled kNet layer (different from not exposed to application))
    - MessageConnection::Process for existing client connections => ..
  - (client)
    - kNet::MessageConnection::Process => Urho3D::Network::HandleMessage =>
      - Connection::ProcessMessage =>
        - switch by msgID. for example for MSG_CREATENODE, ProcessSceneUpdate =>
          - Scene::CreateChild(nodeID, REPLICATED), CreateComponent<SmoothedTransform>(LOCAL)
          - Node::CreateComponent(.. REPLICATED)
    - Urho3D::Connection::ProcessPendingLatestData => (handle out-of-order message about node)
    - OnServerConnected (successfule connection) =>
      - Connection::SendMessage(MSG_IDENTITY ..)
      - SendEvent(E_SERVERCONNECTED) --> ..

- Network::HandleRenderUpdate => PostUpdate -->
  - (server)
    - Scene::PrepareNetworkUpdate from client Connection::GetScene => PrepareNetworkUpdate for MarkNetworkUpdate nodes and components
    - Connection::SendServerUpdate => ProcessNode =>
      - ProcessNewNode => .. SendMessage(MSG_CREATENODE ..)
      - or ProcessExistingNode => .. SendMessage(MSG_NODEDELTAUPDATE ..) (MSG_REMOVECOMPONENT, MSG_COMPONENTLATESTDATA, ..)
    - Connection::SendRemoteEvents => .. SendMessage MSG_REMOTEEVENT, MSG_REMOTENODEEVENT
    - Connection::SendPackages => .. (static file upload)
  - (client)
    - Urho3D::Connection::SendClientUpdate => SendMessage(MSG_CONTROLS ..)
    - Urho3D::Connection::SendRemoteEvents => ..

- SceneReplication::HandlePhysicsPreStep =>
  - (client)
    - Controls on stack with current input state (yaw/forward/back/left/right)
    - Urho3D::Connection::SetControls
  - (server)
    - for each client connection, Connection::GetControls and RigidBody::ApplyTorque

- SceneReplication::HandlePostUpdate => MoveCamera => Camera::SetRotation
```

- Urho3D: enemy navigation (39_CrowdNavigation)
  - ??


# Next time

- libretro, emulator
  - https://www.libretro.com/index.php/getting-started-with-retroarch/
  - frontend example: https://github.com/libretro/RetroArch
  - core example: https://github.com/libretro/mupen64plus-libretro
  - content example: https://www.loveroms.com/roms/nintendo-64
  - dig into linux backend implementation
  - emulator architecture
      - http://mupen64plus.org/docs/
      - https://www.loveroms.com/roms/nintendo-64
      - file format

- Computer graphics
  - volumetric light: https://en.wikipedia.org/wiki/Volumetric_lighting
  - blender 2.8 viewport (eevee)
  - gpu feedback api
  - linux gpu driver implementation
  - linux gl implementation
  - gl memory management (gl buffer data update)
  - height map (with physics)
  - subsurface scattering
  - emission
  - sponza scene: http://www.crytek.com/cryengine/cryengine3/downloads/
  - https://github.com/ashima/webgl-noise/wiki
  - https://github.com/KhronosGroup/glTF
  - shader for skinning
  - PBR (procedual, raster)

- bgfx
  - oit (order independent transparency)
  - lod
  - sdf (single distance field)
  - shadow volume

- tackle these
  - https://www.libretro.com/index.php/api/
  - https://doomwiki.org/wiki/Doom_source_code
  - https://developer.nvidia.com/what-is-gameworks
  - https://github.com/nothings/stb/

- rust implementation
  - llvm binding in rust ?
  - module system (binary module)
  - type system
  - llvm in freestanding
