<!--
{
  "title": "Rails",
  "date": "2017-04-21T16:32:41+09:00",
  "category": "",
  "tags": [],
  "draft": false
}
-->

Just to make it fun using Rails.

# TODO

- [x] ActionController, ActionDispatch::Routing
- [x] ActionView
- [x] session and cookie (ActionDispatch::Session, AD::Session::CookieStore, ::Rack::Session, AD::Cookies)
- [ ] caching (ActionSupport::Cache)
- [ ] ActiveModel, ActiveRecord
- [ ] threading and forking (rack server/app example)
- [ ] logging
- [ ] authentication


# Rails

```
[ Data structure ]

YourApplication < Rails::Application < Rails::Engine < Rails::Railtie
Rails.application (instance of YourApplication)

Rails::Engine
'-' ActionDispatch::Routing::RouteSet
  '-' Journey::Routes
    '-* Journey::Route
  '-' Journey::Router
  '-' NamedRouteCollection

ActionDispatch::Request (include Rack::Request::Helpers, Env)  
ActionDispatch::Session::CookieStore < AbstractStore < ::Rack::Session::Abstract::Persisted

ActionController::Base < Metal < AbstractController::Base
  - and other a lot module chains
    ActionController::Base, ActionController::Rescue, AbstractController::Callbacks, ActiveSupport::Callbacks,
    ActionController::Renderers, ActionController::Rendering, ActionView::Layouts, ActionView::Rendering,
    AbstractController::Logger, AbstractController::Rendering, ActionController::Metal, AbstractController::Base

ActionView::Base
ActionView::Renderer
ActionView::LookupContext


[ Initialization ]
- (Rack server reads config.ru (assume it's Rack::Handler::WEBrick here)) =>
  - require_relative 'config/environment' =>
    - require_relative 'application' =>
      - Bundler.require
      - (class YourApplication < Rails::Application) =>
        - Rails::Application.inherited =>
          - Rails.app_class = YourApplication
    - Rails.application => Rails.app_class.instance =>
      - YourApplication.instance =>
        - Rails::Application.instance =>
          - Rails::Railtie.instance => new =>
            - YourApplication#initialize =>
              - Rails::Application#initialize => ...
          - Rails::Application#run_load_hooks! => ...
    - Rails.application.initialize! => Rails::Application#initialize! =>
      - Rails::Initializable#run_initializers =>
        - ...besides a lot some others ...
  - Rack::Handler::WEBrick.run Rails.application


[ Route construction ]
- "routes.rb" is loaded (Application#routes_reloader and Engine.initializer(:add_routing_paths) or Engine#eager_load!)
- Rails.application.routes.draw (e.g. match('somepath', to: 'ctrl#act', via: :get)) =>
  - ActionDispatch::Routing::RouteSet#draw =>
    - eval_block =>
      - Mapper.new => @scope = Scope.new
      - Mapper#instance_exec =>
        - match => map_match => decomposed_match => add_route =>
          - Mapping.build => Mapping.new
          - RouteSet#add_route(mapping, name) =>
            - Journey::Routes#add_route =>
              - Mapping#make_route =>
                - application => app => Routing::RouteSet::Dispatcher.new
                - Journey::Route.new(..., application, ...)
              - routes << route
            - named_routes[name] = route


[ Rack entrypoint (some possibly lazy initilaization is also written here e.g. middleware stack) ]
- (Rack server calls rack application (e.g. Rack::Handler::Webrick#service)) =>
  - Rails.application.call(env) => Rails::Engine#call =>
    - req = build_request(env) =>
      - req = ActionDispatch::Request.new(env)
      - req.routes = routes =>
        - ActionDispatch::Routing::RouteSet.new_with_config(config (i.e. Engine::Configuration)) =>
          - new => initialize =>
            - named_routes = NamedRouteCollection.new
            - @set = Journey::Routes.new (aliased as routes)
            - @router = Journey::Router.new
    - app =>
      - default_middleware_stack =>
        - ActionDispatch::MiddlewareStack.new
        - (if it's Rails::Application) DefaultMiddlewareStack#build_stack =>
          - use ::Rails::Rack::Logger
          - use config.session_store (e.g. ActionDispatch::Session::CookieStore)
          - ...and a lot others
      - build_middleware =>
        - config => Engine::Configuration.new => Rails::Configuration::MiddlewareStackProxy.new
      - MiddlewareStackProxy#merge_into
      - MiddlewareStack#build(endpoint (a.k.a. routes)) =>
        - ActionDispatch::MiddlewareStack::Middleware#build recursively through registered middlewares
    - app.call(req.env) =>
      - (for simplicity, assumes rack stack is [use Rails::Rack::Logger, run YourApplication.routes])
      - Rails::Rack::Logger#call(env) =>
        - request = ActionDispatch::Request.new(env)
        - call_app(request, env) =>
          - Rails.logger.info { started_request_message(request) } (e.g. "Started <method> <path> for <ip> at <timestamp>")
        - YourApplication.routes.call (SEE BELOW)

- YourApplication.routes.call (RouteSet#call) =>
  - Journey::Router#serve =>
    - find_routes(req) (produces matched Journey::Route) => (TODO)
    - status, headers, body = route.app.serve(req) (Routing::RouteSet::Dispatcher#serve) =>
      - params = req.path_parameters
      - controller = controller(req) =>
        - ActionDispatch::Request#controller_class =>
          - ActiveSupport::Dependencies.constantize params[:controller]
      - res = controller.make_response!(req) =>
        - SomeController
      - dispatch => SomeController.dispatch(action, req, res) (SEE BELOW)
    - return [status, headers, body]


[ Controller instantiation ]
- SomeController.dispatch => ActionController::Metal.dispatch =>
  - new
  - Metal#dispatch => AbstractController::Base#process =>
    - AbstractController::Base#process_action (see AbstractController::Base#ancestors for a bunch of overridings) =>
      - send_action (aliased as send) =>
        - (assume there is SomeController#show with render method call as an example)
        - ActionController::Instrumentation#render =>
          - ActionController::Rendering#render =>
            - AbstractController::Rendering#render =>
              - rendered_body = render_to_body =>
                - ActionController::Renderes#render_to_body => _render_to_body_with_renderer (here :json, :js is handed)
                - (if above routine didn't match) super => ActionView::Rendering#render_to_body (SEE BELOW)
              - ActionController::Base#response_body= rendered_body


[ Template rendering ]
- ActionView::Rendering#render_to_body => _render_template =>
  - view_context =>
    - view_context_class => Class.new(ActionView::Base)
    - ActionView::ViewPaths#lookup_context => ActionView::LookupContext.new
    - view_renderer => ActionView::Renderer.new(lookup_context)
    - view_context_class.new(view_renderer)
  - ActionView::Renderer#render(view_context) => render_template =>
    - TemplateRenderer.new
    - TemplateRenderer#render =>
      - determine_template => AbstractRenderer#find_template => LookupContext#find_template (aliased to find) =>
        - ActionView::PathSet#find => ... =>
          - ActionView::Resolver#find_all => PathResolver#find_templates (within cached block) => query =>
            - extract_handler_and_format_and_variant =>
              - Template.handler_for_extension (assume it's Template::Handlers::ERB instance)
            - Template.new
      - render_template => render_with_layout =>
        - find_layout => find_template
        - yield => Template#render =>
          - compile! => compile =>
            - Handlers::ERB#call (generate ruby code using Handlers::ERB::Erubi (patched version of ::Erubi::Engine))
            - module_eval on view (it's an instance of ActionView::Base with many helpers)
              (this defines method to execute Erubi's generated code)
          - call dynamically defined method
        - Template#render (for layout)
```


# Session, Cookie (a.k.a. HTTP State Management Mechanism)

works as middleware and other complicated stack.

- reference: http://www.ietf.org/rfc/rfc2109.txt ("Set-Cookie", "Cookie")

```
(bind selected store to request)
- ActionDispatch::Session::CookieStore#call =>
  - Rack::Session::Abstract::Persisted#call =>
    - ActionDispatch::Session::CookieStore#prepare_session =>
      - AD::Request::Session.create =>
        - Session.find => AD::Request#get_header(Rack::RACK_SESSION)
        - Session.new
        - Session#merge => load_for_write! => load! => CookieStore#load_session =>
          - unpacked_cookie_data =>
            - Rack::Request#fetch_header("action_dispatch.request.unsigned_session_cookie")
            - CookieStore#get_cookie => cookie_jar => Request#cookie_jar (defined in ad/middleware/cookies.rb) =>
              - cookie_jar = AD::Cookies::CookieJar.build => new
            - CookieJar#signed_or_encrypted => encrypted => EncryptedCookieJar.new
            - EncryptedCookieJar#[@key] => AbstractCookieJar#[] =>
              - EncryptedCookieJar#parse =>
                - ActiveSupport::MessageEncryptor#decrypt_and_verify
                - SerializedCookieJars#deserialize
          - persistent_session_id! =>
            - AD::Session::Compatibility#generate_sid
          - return a pair of session id and "session data" (i.e. plain Hash, which is (de)serialized via SerializedCookieJars)
        - Session.set => AD::Request#set_header(Rack::RACK_SESSION, ...) (i.e. Rack::Request)
    - @app.call
    - Rack::Session::Abstract::Persisted#commit_session =>
      - AD::Session::CookieStore#write_session
      - AD::Session::CookieStore#set_cookie =>
        - EncryptedCookieJar#[@key]= => AbstractCookieJar#[]= =>
          - EncryptedCookieJar#commit =>
            - ActiveSupport::MessageEncryptor#encrypt_and_sign
            - SerializedCookieJars#serialize
```


# Caching

```
[ Initialization ]
- ActionSupport::Cache

[ Use from anywhere ]
- Rails.cache => Rails.application.cache =>

[ Use from view ]
- ActionView::Base#cache =>
```


# Relation database

```
[ Data structure ]
ActiveModel::AttributeAssignment (#assign_attributes)
ActiveModel::AttributeMethods (.define_attribute_methods)

ActiveRecord::Base
ActiveRecord::Core (#initialize, #find, #find_by, .connection_handler)
ActiveRecord::ModelSchema (.table_name, .inheritance_column, .load_schema, .columns_hash, .attribute_types)
ActiveRecord::Attributes (.define_attribute)
ActiveRecord::AttributeMethods (.define_attribute_methods, #attributes)

? .primary_key

AR::Associations (.has_one, .has_many, .belongs_to)
AR::Persistense (.create, #update, #destroy)
ActiveRecord::Querying (methods delegation to :all (e.g. .first, .second))
ActiveRecord::Scoping (.current_scope)
ActiveRecord::Scoping::Named (.all)

ActiveRecord::Relation (#build, #create, #first_or_create, #insert)
ActiveRecord::Relation::QueryMethods (#where)

ActiveRecord::ConnectionHandling (.establish_connection)

ActiveRecord::Schema (.define) < ActiveRecord::Migration::Current

[ connection management ]
- AR::Core.included =>
  - ConnectionAdapters::ConnectionHandler.new => ?

- ActiveRecord::ConnectionHandling.establish_connection =>
- ActiveRecord::ConnectionHandling.connection =>

[ schema to class mapping ]
- Activerecord::ModelSchema.load_schema =>
  - connection.schema_cache.columns_hash(table_name).except(*ignored_columns) ?
  - ActiveRecord::Attributes.define_attribute =>


[ Model interface ]
- method generation
- table relation

[ Migration utility ]
- "bin/rake db:migrate" => ?

[ SQL generation ]
- where composition
- join

[ Connection management ]
-


[ Example ]

[ Example : insert ]
user = User.new(name: 'johndoe')

[ Example : select ]
user = User.where(name: 'johndoe').first
```


# Authentication

```
[ Data structure ]

Warden::Manager
Warden::Proxy
Warden::Strategies::Base

Devise::Engine
Devise::Mapping
Devise::Models
Devise::Strategies::DatabaseAuthenticatable (inherits Warden::Strategies::Base)
ActionDispatch::Routing::Mapping (patching)
Devise::Controllers::Helpers
Devise::Controllers::SignInOut


[ Initialization ]

- Devise::Engine
  - config.app_middleware.use Warden::Manager

- Devise.setup =>
  - require 'devise/orm/activerecord' =>
    - ActiveSupport.on_load(:active_record) { extend Devise::Models }

- Devise::Models#devise(:database_authenticatable) =>
  - include Devise::Models::Authenticatable
  - Devise::Models.const_get('DatabaseAuthenticatable') => Devise::Models::DatabaseAuthenticatable
  - include Devise::Models::DatabaseAuthenticatable

- 'devise/models/database_authenticatable' require 'devise/strategies/database_authenticatable' =>
  - Warden::Strategies.add(:database_authenticatable, Devise::Strategies::DatabaseAuthenticatable)

- ActionDispatch::Routing::Mapping#devise_for('users') =>
  - Devise.add_mapping('users') => Devise::Mapping.new
  - devise_scope('users') =>
    - constraint (request.env["devise.mapping"] = Devise.mappings['users'])
  - devise_session => resource :session (route definition)

- ActionDispatch::Routing::RouteSet.prepend Devise::RouteSet
- Devise::RouteSet#finalize! =>
  - Devise.configure_warden! =>
    - for each Devise::Mapping in Devise.mappings
      - Warden::Config#scope_defaults mapping.name, strategies: mapping.strategies =>
      - set Warden::Config#serialize_into_session be Devise::Models::Authenticable::ClassMethods#serialize_into_session
      - same as Warden::Config#serialize_from_session


[ Request lifecycle (rack call lifecycle) ]

- Wraden::Manager#call =>
  - env['warden'] = Warden::Proxy.new(env, self)

- Devise::SessionsController#create =>
  - Devise::Controllers::Helpers#warden => request.env['warden']
  - Warden::Proxy#authenticate! =>
    - _perform_authentication =>
      - _run_strategies_for =>
        - strategy = _fetch_strategy =>
          - Warden::Strategies[:database_authenticatable] => Devise::Strategies::DatabaseAuthenticatable
          - Devise::Strategies::DatabaseAuthenticatable.new(@env, scope)
        - Devise::Strategies::DatabaseAuthenticatable#_run => authenticate! =>
          - resource = Devise::Models::DatabaseAuthenticable::ClassMethods#find_for_database_authentication =>
            - Authenticable::ClassMethods#find_for_authentication =>
              - to_adapter
      - set_user => ?
    - throw(:warden) on unsuccesful authentication
  - DeviseController#resource_name => devise_mapping => request.env["devise.mapping"] (setup on constraint of devise_scope)
  - Devise::Controllers::SignInOut#sign_in => ?
```
